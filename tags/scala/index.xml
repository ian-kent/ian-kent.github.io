<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Scala on Ian Kent</title>
    <link>http://yourSiteHere/tags/scala/</link>
    <description>Recent content in Scala on Ian Kent</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
    
    <lastBuildDate>Sun, 23 Feb 2014 11:53:37 GMT</lastBuildDate>
    <atom:link href="http://yourSiteHere/tags/scala/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Building a scalable sequence generator (in Scala)</title>
      <link>http://yoursitehere/building-a-scalable-sequence-generator-in-scala/</link>
      <pubDate>Sun, 23 Feb 2014 11:53:37 GMT</pubDate>
      
      <guid>http://yoursitehere/building-a-scalable-sequence-generator-in-scala/</guid>
      <description>

&lt;p&gt;Building a scalable sequence generator was more difficult than I&amp;rsquo;d anticipated.&lt;/p&gt;

&lt;h3 id=&#34;the-challenge:1488174a7a6bea43933aad3fecc4c536&#34;&gt;The challenge&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Build a scalable sequence generator (must scale out and provide resilience)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Master sequence number is stored in MongoDB, updated atomically using find and modify&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sequence numbers must never be repeated (but strict ordering isn&amp;rsquo;t required)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;the-problem:1488174a7a6bea43933aad3fecc4c536&#34;&gt;The problem&lt;/h3&gt;

&lt;p&gt;Since the sequence number is a single value stored in a single document in a single collection, the document gets locked on every request. MongoDB can&amp;rsquo;t help with scaling:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Starting multiple instances of our sequence generator doesn&amp;rsquo;t help, they all need to lock the same document&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Multiple MongoDB nodes doesn&amp;rsquo;t help - we&amp;rsquo;d need &lt;a href=&#34;http://docs.mongodb.org/manual/core/write-concern/#replica-acknowledged&#34;&gt;replica acknowledged write concern&lt;/a&gt; to avoid duplicate sequence numbers&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;the-solution:1488174a7a6bea43933aad3fecc4c536&#34;&gt;The solution&lt;/h3&gt;

&lt;p&gt;The solution is to take batches of sequence numbers from MongoDB, multiplying the scalability - for example, using a batch size of 10 means we can run (approximately) 10 instances of our sequence generator to our 1 MongoDB document, though any instance failure could waste up to 10 sequence numbers.&lt;/p&gt;

&lt;p&gt;Using batches also dramatically improves our performance - we make far fewer MongoDB requests, generating less network traffic and reducing service response times.&lt;/p&gt;

&lt;h4 id=&#34;the-unscalable-sequence-generator:1488174a7a6bea43933aad3fecc4c536&#34;&gt;The unscalable sequence generator&lt;/h4&gt;

&lt;p&gt;Building an unscalable sequence generator is easy. We can just find and modify the next sequence, MongoDB takes care of the rest.&lt;/p&gt;

&lt;p&gt;An implementation might look a bit like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;object UnscalableSequenceGenerator extends App {
  // the master sequence number
  var seq = 0

  def nextSeq : Future[Int] = future { blocking {
    // pretend we&#39;re doing a find and modify asynchronously
    Thread.sleep(30)
    this.synchronized {
      seq = seq + 1
      seq
    }
  } }

  // simulate calling our HTTP service 100 times
  for(i &amp;lt;- 1 to 100) {
    nextSeq map { j =&amp;gt;
      // pretend we&#39;re doing something useful with the sequence number
      print(s&amp;quot;$j &amp;quot;)
      if(i % 10 == 0) println
    }
  }

  Thread.sleep(5000)
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running that example produces output like this (the exact ordering of numbers may be different):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;2 3 1 4 5 7 6 8 9 10 11 12 
14 13 16 17 15 19 18 21 22 20 24 23 25 
26 27 28 30 29 
31 32 34 33 36 35 37 38 39 40 41 43 42 
44 46 45 47 48 49 50 51 52 
53 55 54 56 57 58 60 59 
62 61 63 64 65 66 67 68 69 70 
71 72 74 73 75 76 78 77 80 79 81 
82 83 85 84 86 87 89 88 90 91 
93 95 92 96 97 94 99 98 100 
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No duplicates, but it&amp;rsquo;s not scalable, and the performance is terrible.&lt;/p&gt;

&lt;h4 id=&#34;making-it-scalable:1488174a7a6bea43933aad3fecc4c536&#34;&gt;Making it scalable&lt;/h4&gt;

&lt;p&gt;To make it scalable (and get a performance boost), we can use sequence number batches. But that turned out to be more difficult than I&amp;rsquo;d expected.&lt;/p&gt;

&lt;p&gt;The first attempt looked a bit like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;object BatchedSequenceGenerator extends App {
  // the master sequence number and batch size
  var seq = 0
  val batch_size = 10

  // our current sequence and maximum sequence numbers
  var local_seq = 0
  var local_max = 0

  def newBatch : Future[Int] = future { blocking {
    // pretend we&#39;re doing a find and modify asynchronously
    Thread.sleep(30)
    this.synchronized {
        seq = seq + 10
        seq
    }
  } }

  def nextSeq : Future[Int] = {
    if(local_seq &amp;gt;= local_max) {
      // Get a new batch of sequence numbers
      newBatch map { new_max =&amp;gt;
        // Update our local sequence
        local_max = new_max
        local_seq = local_max - batch_size
        local_seq = local_seq + 1
        local_seq
      }
    } else {
      // Use our local sequence number
      val next_seq = local_seq
      local_seq = local_seq + 1
      future { next_seq }
    }
  }

  // simulate calling our HTTP service 100 times
  for(i &amp;lt;- 1 to 100) nextSeq map { j =&amp;gt;
    // pretend we&#39;re doing something useful with the sequence number
    print(s&amp;quot;$j &amp;quot;)
    if(i % 10 == 0) println
  }

  Thread.sleep(5000)
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While it does at least take batches of sequence numbers, we get the following unexpected but understandable output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;11 1 41 61 71 91 21 31 121 181 191 131 141 151 161 171 201 211 221 
101 81 111 51 
231 251 241 261 271 281 291 301 
311 321 331 341 351 361 371 381 
391 401 411 421 441 431 451 461 471 
481 491 501 511 521 531 541 551 
561 571 581 591 601 611 621 631 641 651 661 671 681 701 701 731 731 721 
741 751 761 791 781 771 801 811 821 831 841 
861 871 851 881 891 911 
901 921 931 951 961 941 971 
991 981
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;re only using 1/10th of each batch, and we get to 991 in only 100 requests. It&amp;rsquo;s no more scalable than the unbatched version.&lt;/p&gt;

&lt;p&gt;It should probably have been obvious, but the problem is caused by requests arriving between requesting a new batch and getting a response:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The 10th request gives out the last local sequence number&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The 11th request gets a new batch asynchronously&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The 12th request arrives before we get a new batch, and requests another new batch asynchronously&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We get the 11th request batch, reset our sequence numbers and return a sequence&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We get the 12th request batch, and again reset our sequence numbers and return a sequence, wasting the rest of the previous batch&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To fix it, we need the 12th request to wait for the 11th request to complete first.&lt;/p&gt;

&lt;h4 id=&#34;making-it-work:1488174a7a6bea43933aad3fecc4c536&#34;&gt;Making it work&lt;/h4&gt;

&lt;p&gt;This was the tricky bit - implementing it led me down a road of endless compiler errors, but the idea was simple.&lt;/p&gt;

&lt;p&gt;When we call &lt;code&gt;nextSeq&lt;/code&gt;, we need to know if a new batch request is pending. If it is, instead of requesting a new batch, we need to wait for the existing request to complete, otherwise handle the request as normal.&lt;/p&gt;

&lt;p&gt;We can do this by chaining futures together, keeping track of whether a batch request is currently in progress.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s a fairly simple change to our batched sequence generator (or at least, in hindsight it is):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;object BatchedSequenceGenerator extends App {
  // the master sequence number and batch size
  var seq = 10
  val batch_size = 10

  // our current sequence and maximum sequence numbers
  var local_seq = 0
  var local_max = 10
  var pending : Option[Future[Int]] = None

  def newBatch : Future[Int] = future { blocking {
    // pretend we&#39;re doing a find and modify asynchronously
    Thread.sleep(30)
    this.synchronized {
      seq = seq + batch_size
      seq
    }
  } }

  def nextSeq : Future[Int] = this.synchronized {
    pending match {
      case None =&amp;gt;
        if(local_seq &amp;gt;= local_max) {
          // Get a new batch of sequence numbers
          pending = Some(newBatch map { new_max =&amp;gt;
            // Update our local sequence
            local_max = new_max
            local_seq = local_max - batch_size + 1
            local_seq
          })
          // Clear the pending future once we&#39;ve got the batch
          pending.get andThen { case _ =&amp;gt; pending = None }
        } else {
          // Use our local sequence number
          local_seq = local_seq + 1
          val seq = local_seq
          future(seq)
        }
      case Some(f) =&amp;gt;
        // Wait on the pending future
        f flatMap { f =&amp;gt; nextSeq }
    }
  }

  // simulate calling our HTTP service 100 times
  for(i &amp;lt;- 1 to 100) nextSeq map { j =&amp;gt;
    // pretend we&#39;re doing something useful with the sequence number
    print(s&amp;quot;$j &amp;quot;)
    if(i % 10 == 0) println
  }

  Thread.sleep(5000)
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And running that example generates output like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;3 5 6 2 7 8 9 10 
4 1 13 11 12 14 15 17 19 20 
16 18 23 21 24 26 27 28 29 30 22 
25 34 35 31 33 37 38 39 40 
32 36 45 41 44 46 47 48 43 
49 50 42 52 53 55 51 60 54 56 
57 58 59 62 
64 70 63 61 65 66 67 68 69 72 75 71 
73 74 76 77 78 80 79 82 83 85 84 86 87 81 
89 88 90 92 95 93 99 98 100 97 
96 91 94 
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The changes we made are straightforward:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;When we request a new sequence number, check if a pending future exists&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If it does, wait on that and return a new call to nextSeq&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If not, check if a new batch is required&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If it is, store the future before returning&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It not, use the existing batch as normal&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A limitation of this approach - if we have a sufficiently small batch size with a high volume of requests, the considerable number of chained futures could potentially cause out of memory errors.&lt;/p&gt;

&lt;p&gt;Getting it to work felt like an achievement, but I&amp;rsquo;m still not happy with the code. It looks like there should be a nicer way to do it, and it doesn&amp;rsquo;t feel all that functional, but I can&amp;rsquo;t see it yet!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Quick start with Scala and Play Framework</title>
      <link>http://yoursitehere/quick-start-with-scala-and-play-framework/</link>
      <pubDate>Thu, 13 Feb 2014 19:23:23 GMT</pubDate>
      
      <guid>http://yoursitehere/quick-start-with-scala-and-play-framework/</guid>
      <description>&lt;p&gt;For the quick and dirty way to get &lt;a href=&#34;http://www.playframework.com/&#34;&gt;Play Framework&lt;/a&gt; up and running, you need only these:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://vagrantup.com&#34;&gt;Vagrant&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.virtualbox.org/&#34;&gt;VirtualBox&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://git-scm.com/download/win&#34;&gt;Git for Windows&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once they&amp;rsquo;re all installed, its this easy:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Open Git Bash&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Clone my &lt;a href=&#34;https://github.com/ian-kent/vagrant-scala-play-mongodb&#34;&gt;Play/Scala vagrant repository&lt;/a&gt;: &lt;code&gt;git clone https://github.com/ian-kent/vagrant-scala-play-mongodb.git playserver&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Change directory: &lt;code&gt;cd playserver&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Start the virtual machine: &lt;code&gt;vagrant up&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Once it&amp;rsquo;s complete, connect using SSH: &lt;code&gt;vagrant ssh&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Create a new play app: &lt;code&gt;play new MyApp&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Change directory: &lt;code&gt;cd MyApp&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Start your application: &lt;code&gt;play run&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;View your new Play site in a browser: &lt;code&gt;http://localhost:9000&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you want to edit your Play project in &lt;a href=&#34;http://www.jetbrains.com/idea/&#34;&gt;IntelliJ Idea&lt;/a&gt;, create the project files from the command line using &lt;code&gt;play gen-idea&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To help you get started, the Vagrantfile also installs &lt;a href=&#34;http://www.mongodb.org/&#34;&gt;MongoDB&lt;/a&gt; and sets up port forwarding for port 9000 (Play) and port 27017 (MongoDB)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Globally handling OPTIONS requests in Play Framework</title>
      <link>http://yoursitehere/globally-handling-options-requests-in-play-framework/</link>
      <pubDate>Tue, 11 Feb 2014 21:38:30 GMT</pubDate>
      
      <guid>http://yoursitehere/globally-handling-options-requests-in-play-framework/</guid>
      <description>

&lt;p&gt;If you&amp;rsquo;re using AJAX to talk to a Play Framework application, you&amp;rsquo;ll probably need to respond to OPTIONS requests and might need to return the correct access control (CORS) headers.&lt;/p&gt;

&lt;p&gt;In a controller, we can easily define a handler to accept OPTIONS requests:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def headers = List(
  &amp;quot;Access-Control-Allow-Origin&amp;quot; -&amp;gt; &amp;quot;*&amp;quot;,
  &amp;quot;Access-Control-Allow-Methods&amp;quot; -&amp;gt; &amp;quot;GET, POST, OPTIONS, DELETE, PUT&amp;quot;,
  &amp;quot;Access-Control-Max-Age&amp;quot; -&amp;gt; &amp;quot;3600&amp;quot;,
  &amp;quot;Access-Control-Allow-Headers&amp;quot; -&amp;gt; &amp;quot;Origin, Content-Type, Accept, Authorization&amp;quot;,
  &amp;quot;Access-Control-Allow-Credentials&amp;quot; -&amp;gt; &amp;quot;true&amp;quot;
)

def options = Action { request =&amp;gt;
  NoContent.withHeaders(headers : _*)
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we can call our new options handler from our routes file, but this has a few problems. We either need to implement an options handler for every route, or we send the same response whatever route we have, even if it doesn&amp;rsquo;t exist.&lt;/p&gt;

&lt;h3 id=&#34;per-route:690e640b2fe5a8e8798609567de62b3e&#34;&gt;Per-route&lt;/h3&gt;

&lt;p&gt;If you want to respond on a per-route basis, that typically requires one additional line in your routes file for every route you define:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;GET / controllers.Application.index
OPTIONS / controllers.Application.options
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;globally:690e640b2fe5a8e8798609567de62b3e&#34;&gt;Globally&lt;/h3&gt;

&lt;p&gt;Or, if you don&amp;rsquo;t mind sending the same headers back for every OPTIONS request (even if the route doesn&amp;rsquo;t really exist), there&amp;rsquo;s a cheat:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;OPTIONS / controllers.Application.rootOptions
OPTIONS /*url controllers.Application.options(url: String)
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and change your controller options handler to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def rootOptions = options(&amp;quot;/&amp;quot;)   
def options(url: String) = Action { request =&amp;gt;
  NoContent.withHeaders(headers : _*)
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can still override the global OPTIONS per-route by adding additional routes before the wildcard, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;OPTIONS /foo controllers.Application.someCustomOptions
OPTIONS / controllers.Application.rootOptions
OPTIONS /*url controllers.Application.options(url: String)
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;or-we-can-abuse-play-framework-the-best-way:690e640b2fe5a8e8798609567de62b3e&#34;&gt;Or we can abuse Play Framework - the best way!&lt;/h3&gt;

&lt;p&gt;Play Framework doesn&amp;rsquo;t like to expose its routing, making it difficult to inspect the routing table once its been created. But it is possible! Doing that, we can globally handle OPTIONS requests but dynamically respond based on URL (or even other request parameters).&lt;/p&gt;

&lt;p&gt;For this example, we&amp;rsquo;ll work out the &lt;code&gt;Allow&lt;/code&gt; header so we can return a 204 response if the route would normally exist, but a 404 response if it wouldn&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;This is the example routes file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;GET /           controllers.Application.index
GET /foo        controllers.Application.foo
OPTIONS /       controllers.Application.rootOptions
OPTIONS /*url   controllers.Application.options(url: String)
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When sending OPTIONS requests, we want to respond with 204 and &lt;code&gt;Allow: GET, OPTIONS&lt;/code&gt; for &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;/foo&lt;/code&gt;, but respond with 404 for everything else.&lt;/p&gt;

&lt;h4 id=&#34;getting-the-methods-available-for-a-url:690e640b2fe5a8e8798609567de62b3e&#34;&gt;Getting the methods available for a URL&lt;/h4&gt;

&lt;p&gt;Play Framework gives us a convenient function - &lt;code&gt;handlerFor&lt;/code&gt; - which is normally used to route requests to a handler. For this to work, you&amp;rsquo;ll need to add an import:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;import play.api.Play.current
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then define a &lt;code&gt;getMethods&lt;/code&gt; function, which given a request will return a list of available methods. It does this by asking Play Framework to route new requests with modified method parameters. If a handler is found, the method is added to the list. The list is also cached for future requests.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;val methodList = List(&amp;quot;GET&amp;quot;, &amp;quot;POST&amp;quot;, &amp;quot;PUT&amp;quot;, &amp;quot;DELETE&amp;quot;, &amp;quot;PATCH&amp;quot;)
def getMethods(request: Request[AnyContent]) : List[String] = {
  Cache.getOrElse[List[String]](&amp;quot;options.url.&amp;quot; + request.uri) {
    for(m &amp;lt;- methodList; if Play.application.routes.get.handlerFor(new RequestHeader {
      val remoteAddress = request.remoteAddress
      val headers = request.headers
      val queryString = request.queryString
      val version = request.version
      val method = m
      val path = request.path
      val uri = request.uri
      val tags = request.tags
      val id: Long = request.id
    }).isDefined) yield m
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then update our options action to use the new method list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def options(url: String) = Action { request =&amp;gt;
  val methods = List(&amp;quot;OPTIONS&amp;quot;) ++ getMethods(request)
  if(methods.length &amp;gt; 1)
    NoContent.withHeaders(List(&amp;quot;Allow&amp;quot; -&amp;gt; methods.mkString(&amp;quot;, &amp;quot;)) : _*)
  else
    NotFound
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We add OPTIONS back in, and if we have more than one method we return the Allow header, otherwise a 404 response.&lt;/p&gt;

&lt;p&gt;We could instead cache the entire response for a given URI, but caching just the method list gives us the flexibility to set other headers which may be more dynamic, for example Last-Modified. Even the current caching might be too restrictive if the available methods depends on other request parameters.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Action composition in Play Framework</title>
      <link>http://yoursitehere/action-composition-in-play-framework/</link>
      <pubDate>Mon, 10 Feb 2014 16:32:47 GMT</pubDate>
      
      <guid>http://yoursitehere/action-composition-in-play-framework/</guid>
      <description>

&lt;p&gt;Action composition in Play Framework is an incredibly powerful way to enhance or restrict controller behaviour, for example to implement authentication or authorisation controls, set default headers, or handle OPTIONS requests.&lt;/p&gt;

&lt;p&gt;But typical action composition can be messy. Using action builders, we can simplify the process - and you may have already used them without realising it!&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ve probably seen code like this before, it&amp;rsquo;s pretty standard stuff:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Action { request =&amp;gt;
  Ok(views.html.index(&amp;quot;Your new application is ready.&amp;quot;))
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And if you&amp;rsquo;ve used Play Framework asynchronously, maybe something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Action.async { request =&amp;gt;
  doSomething map { result =&amp;gt;
    Ok(views.html.index(&amp;quot;Your new application is ready.&amp;quot;))
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also easily parse the request using a different content type (or &amp;ldquo;body parser&amp;rdquo;), for example using JSON:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Action.async(parse.json) { request =&amp;gt;
  doSomething map { result =&amp;gt;
    Ok(Json.obj(result -&amp;gt; &amp;quot;Your new application is ready.&amp;quot;))
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All of these use the Action action builder (that is, the Action object, which is an action builder).&lt;/p&gt;

&lt;p&gt;By creating a new action builder, we can create a drop-in replacement for the Action calls (both &lt;code&gt;Action&lt;/code&gt; and &lt;code&gt;Action.async&lt;/code&gt;), while still supporting the body parser parameter.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-new-action-builder:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Creating a new action builder&lt;/h2&gt;

&lt;p&gt;Since &lt;code&gt;Action&lt;/code&gt; is just an implementation of &lt;code&gt;ActionBuilder[Request]&lt;/code&gt;, we can extend &lt;code&gt;ActionBuilder&lt;/code&gt; to use in place of &lt;code&gt;Action&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;ActionBuilder requires that we implement &lt;code&gt;invokeBlock&lt;/code&gt;, and that&amp;rsquo;s where the magic happens. This is a bare minimum implementation, and its exactly what &lt;code&gt;Action&lt;/code&gt; does for us already.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;invokeBlock&lt;/code&gt; takes two parameters, the first is the incoming request, and the second is the function body, taking &lt;code&gt;Request[A]&lt;/code&gt; as a parameter and returning a &lt;code&gt;Future[SimpleResult]&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;object Interceptor extends ActionBuilder[Request] {
  def invokeBlock[A](request: Request[A], block: (Request[A]) =&amp;gt; Future[SimpleResult]) = block(request)
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It doesn&amp;rsquo;t do much (in fact, nothing different from &lt;code&gt;Action&lt;/code&gt;), but now we can use that in our controller instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Interceptor.async(parse.json) { request =&amp;gt;
  doSomething map { result =&amp;gt;
    Ok(Json.obj(result -&amp;gt; &amp;quot;Your new application is ready.&amp;quot;))
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And it works using the same syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Interceptor { request =&amp;gt; Ok }
def index = Interceptor.async { request =&amp;gt; future { Ok } }
def index = Interceptor(parse.json) { request =&amp;gt; Ok }
def index = Interceptor.async(parse.json) { request =&amp;gt; future { Ok } }
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;intercepting-requests:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Intercepting requests&lt;/h3&gt;

&lt;p&gt;There&amp;rsquo;s many reasons to intercept a request before it reaches your controller - authentication, authorisation, rate limiting or performance monitoring - for this example, we&amp;rsquo;ll use authentication.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s also many ways to authenticate a request - using headers, cookies, etc. - and while this is one way you certainly wouldn&amp;rsquo;t do it, it works for a demo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;object Authenticated extends ActionBuilder[Request] {
  def invokeBlock[A](request: Request[A], block: (Request[A]) =&amp;gt; Future[SimpleResult]) = {
    if(request.headers.get(&amp;quot;Authorization&amp;quot;).isDefined)
      block(request)
    else
      future { Results.Status(Status.UNAUTHORIZED) }
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This very simple example checks for an Authorization header.&lt;/p&gt;

&lt;p&gt;If it&amp;rsquo;s there, it calls &lt;code&gt;block(request)&lt;/code&gt; and request processing continues as expected (don&amp;rsquo;t confuse the word &amp;ldquo;block&amp;rdquo; to mean the request gets blocked, we&amp;rsquo;re actually executing the code block or function body we were passed earlier).&lt;/p&gt;

&lt;p&gt;If the Authorization header isn&amp;rsquo;t found, it returns an Unauthorized (401) response, using &lt;code&gt;Results.Status()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;At this point we could have returned any &lt;code&gt;Future[SimpleResult]&lt;/code&gt; we like. We could look up data in memcached, MongoDB or call a remote API using OAuth2 - and either let the request continue, or return an appropriate response instead.&lt;/p&gt;

&lt;p&gt;But this isn&amp;rsquo;t ideal - we&amp;rsquo;ve got our action builder sending a response to the client. We need to pass that responsibility back to the controller.&lt;/p&gt;

&lt;h3 id=&#34;passing-user-context:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Passing user context&lt;/h3&gt;

&lt;p&gt;So far, we&amp;rsquo;ve intercepted the request using action composition, but once we get to the controller code we don&amp;rsquo;t know who the user is, and no way to find out if we couldn&amp;rsquo;t establish the users identity.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s plenty of ways to fix this - &lt;a href=&#34;http://www.playframework.com/documentation/2.2.x/ScalaActionsComposition&#34;&gt;some of them documented in the Play Framework action composition documentation&lt;/a&gt; - but we&amp;rsquo;ll go with wrapping the request class.&lt;/p&gt;

&lt;p&gt;This has the advantage of keeping all existing code &amp;lsquo;compatible&amp;rsquo; - we can simply search and replace Action for Authenticated and every endpoint is protected.&lt;/p&gt;

&lt;p&gt;For a comparison, here&amp;rsquo;s what the controller would have looked like if we&amp;rsquo;d wrapped the action:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Authenticated { user =&amp;gt; 
  Action { request =&amp;gt;
    Ok(user.get)
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here&amp;rsquo;s what we&amp;rsquo;re going to create with our custom request class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Authenticated { request =&amp;gt;
  Ok(request.user.get)
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;wrapping-the-request-class:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Wrapping the request class&lt;/h4&gt;

&lt;p&gt;To wrap the request class, and be able to access the user object from our controllers without casting the request first, we need to create a new trait and a new object.&lt;/p&gt;

&lt;p&gt;The trait &lt;code&gt;AuthenticatedRequest&lt;/code&gt; simply extends &lt;code&gt;Request&lt;/code&gt; and adds a user value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;trait AuthenticatedRequest[+A] extends Request[A] {
  val user: Option[JsObject]
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The object &lt;code&gt;AuthenticatedRequest&lt;/code&gt; is similar to &lt;code&gt;play.api.mvc.Http.Request&lt;/code&gt; - except we copy the existing request, and add the user value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;object AuthenticatedRequest {
  def apply[A](u: Option[JsObject], r: Request[A]) = new AuthenticatedRequest[A] {
    def id = r.id
    def tags = r.tags
    def uri = r.uri
    def path = r.path
    def method = r.method
    def version = r.version
    def queryString = r.queryString
    def headers = r.headers
    lazy val remoteAddress = r.remoteAddress
    def username = None
    val body = r.body
    val user = u
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we need to change our call to &lt;code&gt;block(request)&lt;/code&gt; to pass through our new &lt;code&gt;AuthenticatedRequest&lt;/code&gt; object.&lt;/p&gt;

&lt;p&gt;To make this work, we also need to change &lt;em&gt;some&lt;/em&gt; of the &lt;code&gt;Request&lt;/code&gt; types to &lt;code&gt;AuthenticatedRequest&lt;/code&gt; in our &lt;code&gt;Authenticated&lt;/code&gt; object. We&amp;rsquo;ve also let the request continue even without a valid user - we can use this from a controller to know the users identity couldn&amp;rsquo;t be established.&lt;/p&gt;

&lt;p&gt;Here it is in full:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;object Authenticated extends ActionBuilder[AuthenticatedRequest] {
  def invokeBlock[A](request: Request[A], block: (AuthenticatedRequest[A]) =&amp;gt; Future[SimpleResult]) = {
    if(request.headers.get(&amp;quot;Authorization&amp;quot;).isDefined)
      block(AuthenticatedRequest[A](Some(Json.obj()), request))
    else
      block(AuthenticatedRequest[A](None, request))
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that invokeBlock still expects a &lt;code&gt;Request[A]&lt;/code&gt; as its request parameter, but now the block parameter defines a function with a &lt;code&gt;AuthenticatedRequest[A]&lt;/code&gt; parameter instead.&lt;/p&gt;

&lt;p&gt;For now, our user is nothing more than an empty JsObject. In a real application, it could be any type (not just JsObject), and the value for user could come from anywhere (e.g. a database, session, OAuth2, etc).&lt;/p&gt;

&lt;p&gt;When authentication fails, we pass through &lt;code&gt;None&lt;/code&gt;, letting the controller know that no user could be found.&lt;/p&gt;

&lt;p&gt;From our controller, we can now access the user object with &lt;code&gt;request.user&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Authenticated.async { request =&amp;gt;
  future { Ok(request.user.get) }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;authorisation:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Authorisation&lt;/h3&gt;

&lt;p&gt;So far we&amp;rsquo;ve seen how to require authentication using an action builder. While this is useful if your app uses an &amp;lsquo;all or nothing&amp;rsquo; security model, this isn&amp;rsquo;t particularly useful for authorisation, for example in role based security.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s two easy ways to solve this problem:&lt;/p&gt;

&lt;h4 id=&#34;create-another-action-builder-to-wrap-our-authenticated-builder:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Create another action builder to wrap our Authenticated builder&lt;/h4&gt;

&lt;p&gt;We can wrap our Authenticated action builder with another builder, giving us controller code that might look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Authorised(roles = List(&amp;quot;blog.post&amp;quot;)) { request =&amp;gt;
  Ok(request.user.get)
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is very straightforward, but creates an unnecessary dependency between your authorisation and authentication code.&lt;/p&gt;

&lt;h4 id=&#34;use-normal-action-composition-to-require-authorisation:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Use normal action composition to require authorisation&lt;/h4&gt;

&lt;p&gt;Using action composition, we might end up with code that looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Authenticated { request =&amp;gt;
  Authorised(roles = List(&amp;quot;blog.post&amp;quot;)) {
    Ok(request.user.get)
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we can also do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Authorised(roles = List(&amp;quot;blog.post&amp;quot;)) { request =&amp;gt;
  Ok(request.user.get)
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The downside to normal action composition is obvious once you start using different body parsers or asynchronous operations:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Authenticated(parse.json).async { request =&amp;gt;
  Authorised(parse.json).async(roles = List(&amp;quot;blog.post&amp;quot;)) {
    future { Ok(request.user.get) }
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On every nested action we are required to redeclare the body parser and call async.&lt;/p&gt;

&lt;h4 id=&#34;but-this-is-scala-there-s-a-nicer-way:8a4e04e27a605e28f409c700d00877c8&#34;&gt;But this is Scala - there&amp;rsquo;s a nicer way!&lt;/h4&gt;

&lt;p&gt;Neither of those examples are particularly suitable. Neither will cleanly handle a negative outcome (either needing some messy code or hiding the unauthorised response away in a helper class), and neither of them nest well.&lt;/p&gt;

&lt;p&gt;Whenever you need to check authorisation, the outcome is normally one of two things - in the case of a web application, its likely that both of them will end in returning some content to the user.&lt;/p&gt;

&lt;p&gt;In true MVC style, this shouldn&amp;rsquo;t be the responsibility of the authorisation code. It should be in the controller.&lt;/p&gt;

&lt;p&gt;We could just use an if/then/else statement, but I like something a bit cleaner:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Authenticated { request =&amp;gt;
  Authorised(request, request.user) {
    Ok(request.user.get)
  } otherwise {
    Unauthorized
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And our &lt;code&gt;Authorised&lt;/code&gt; implementation is simple. We provide &lt;code&gt;Authorised&lt;/code&gt; and &lt;code&gt;Authorised.async&lt;/code&gt; functions, and return an instance of our &lt;code&gt;Authorised&lt;/code&gt; class providing an &lt;code&gt;otherwise&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;object Authorised {
  def async[T](request: Request[T], user: Option[JsObject]) = {
    (block: Future[SimpleResult]) =&amp;gt; new Authorised[T](request, user, block)
  }
  def apply[T](request: Request[T], user: Option[JsObject]) = {
    (block: SimpleResult) =&amp;gt; new Authorised[T](request, user, future { block })
  }
}

class Authorised[T](request: Request[T], user: Option[JsObject], success: Future[SimpleResult]) {
  def authorised = {
    if(user.isDefined) true else false
  }
  def otherwise(block: Future[SimpleResult]) : Future[SimpleResult] = authorised.flatMap { valid =&amp;gt; if (valid) success else block }
  def otherwise(block: SimpleResult) : SimpleResult = if(authorised.value.get.get) success.value.get.get else block
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As with the Authentication action builder, this implementation isn&amp;rsquo;t particularly secure. As long as the user is defined (which it will be if the Authorization header is set), then authorisation is successful.&lt;/p&gt;

&lt;p&gt;In this example we&amp;rsquo;ve also passed the request object to the authorisation layer. It would be cleaner to abstract the request from our authorisation code using named roles or permissions.&lt;/p&gt;

&lt;h3 id=&#34;action-builder-vs-helper-object:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Action builder vs helper object&lt;/h3&gt;

&lt;p&gt;There&amp;rsquo;s a reason we&amp;rsquo;ve created authentication as an action builder but kept authorisation as a helper object.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Authentication&lt;/em&gt; is a one-time process (for each request) - it rarely needs to be done multiple times, and it rarely changes once the request has been received. Even if we can&amp;rsquo;t establish the identity of the user, that doesn&amp;rsquo;t necessarily mean authentication has failed or that the user has no permissions.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Authorisation&lt;/em&gt; can happen multiple times within one request, in one controller, and with distinct outcomes - for example, rendering a dashboard might perform multiple unique authorisation checks to determine appropriate components for a single page.&lt;/p&gt;

&lt;p&gt;By keeping the authorisation check as a helper object, we can use it mutliple times within a controller action, passing different parameters each time, and with the flexibility to control the outcome of each check.&lt;/p&gt;

&lt;p&gt;For example, we could return &lt;code&gt;NotFound&lt;/code&gt; for one level of authorisation failure, but &lt;code&gt;Unauthorized&lt;/code&gt; for another:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Authenticated(parse.json) { request =&amp;gt;
  Authorised(request, request.user) {
    Authorised(request, Some(Json.obj())) {
      Ok(request.user.get)
    } otherwise {
      Unauthorized
    }
  } otherwise {
    NotFound
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;summary:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ve now created an authentication and authorisation layer for our web application, which supports the same syntax as the built in Play objects. For a simple application, that&amp;rsquo;s all you need - just wire in MongoDB or OAuth2!&lt;/p&gt;

&lt;p&gt;The same idea can be applied to any other type of wrapper. You can even create action builders and helper objects which combine other wrappers, for example automatically applying authentication, authorisation and rate limiting through a single builder.&lt;/p&gt;

&lt;h2 id=&#34;going-a-bit-further-with-akka:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Going a bit further with Akka&lt;/h2&gt;

&lt;p&gt;While it would be easy to extend that example to lookup users, roles and permissions in MongoDB, or restrict actions based on IP address, in Scala (and Play Framework) we can do things a little differently.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s no reason for authentication or authorisation to be tied to your application - they aren&amp;rsquo;t really a direct responsibility of your web application anyway, but they&amp;rsquo;re often left there for convenience.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://akka.io&#34;&gt;Akka&lt;/a&gt; provides us with a framework to build distributed and concurrent applications - and we can keep our application concurrent and distributed right through to the authentication and authorisation layers. And better yet, it&amp;rsquo;s already used internally by Play Framework.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll extend this example to use an actor for authentication and authorisation, giving us the flexibility to move our authentication code anywhere - even to a remote service with Akka remoting.&lt;/p&gt;

&lt;h3 id=&#34;creating-an-actor:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Creating an actor&lt;/h3&gt;

&lt;p&gt;For now, we&amp;rsquo;ll just keep our actor next to our action builder. Moving it around later is easy.&lt;/p&gt;

&lt;p&gt;First we&amp;rsquo;ll create some basic case classes to communicate using Akka:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;case class Authenticate[A](request: Request[A])
case class AuthenticationResult(valid: Boolean, user: Option[JsObject] = None)
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can extend these classes if we want to provide additional context or return additional information.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s our basic actor - it implements a receive function to handle incoming messages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;class Authenticator extends Actor {
  def receive = {
    case Authenticate(request) =&amp;gt; 
      if(request.headers.get(&amp;quot;Authorization&amp;quot;).isDefined)
        sender ! AuthenticationResult(valid = true, user = Json.obj())
      else 
        sender ! AuthenticationResult(valid = false)
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s only job is to return an AuthenticationResult depending on the request. It provides the same super strength foolproof security we had with our earlier example.&lt;/p&gt;

&lt;h3 id=&#34;using-the-actor-for-authentication:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Using the actor for authentication&lt;/h3&gt;

&lt;p&gt;We need to get an instance of our actor for our &lt;code&gt;Authenticated&lt;/code&gt; object. We&amp;rsquo;ll send &lt;code&gt;Authenticate&lt;/code&gt; requests to the actor, and get an &lt;code&gt;AuthenticationResult&lt;/code&gt; back:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;val authenticationActor = Akka.system.actorOf(Props[Authenticator], name = &amp;quot;authentication&amp;quot;)
implicit val timeout = Timeout(1 second)
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now update our &lt;code&gt;invokeBlock&lt;/code&gt; function to use the actor instead of including its own authentication logic. If authentication was successful, the actor returns the &lt;code&gt;JsObject&lt;/code&gt; representing the user.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def invokeBlock[A](request: Request[A], block: (AuthenticatedRequest[A]) =&amp;gt; Future[SimpleResult]) = {
  (authenticationActor ask Authenticate(request)).mapTo[AuthenticationResult] flatMap { result =&amp;gt;
    if(result.valid)
      block(AuthenticatedRequest[A](Some(result.user.get), request))
    else
      block(AuthenticatedRequest[A](None, request))
  } recover {
    case e =&amp;gt; Results.Status(Status.INTERNAL_SERVER_ERROR)
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can extend our authorisation class in exactly the same way, again sending the authorisation request to an actor. I&amp;rsquo;ll skip it here since the code is so similar to the authentication actor, but you can find it in the full source code on &lt;a href=&#34;https://gist.github.com/ian-kent/8941847&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;summary-1:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Action composition in Play Framework is surprisingly easy, and very powerful.&lt;/p&gt;

&lt;p&gt;Using action builders combined with Scala&amp;rsquo;s concurrency and Akka&amp;rsquo;s distributed framework, it&amp;rsquo;s simple to keep your controller code clean without sacrificing security or scalability across your application.&lt;/p&gt;

&lt;p&gt;Full source code for the Akka example can be &lt;a href=&#34;https://gist.github.com/ian-kent/8941847&#34;&gt;found on GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>