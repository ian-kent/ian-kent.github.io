<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ian Kent</title>
    <link>http://yourSiteHere/</link>
    <description>Recent content on Ian Kent</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
    
    <lastBuildDate>Mon, 08 Sep 2014 20:49:30 &#43;0000</lastBuildDate>
    <atom:link href="http://yourSiteHere/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Management and the frozen lake (and how coffee helps)</title>
      <link>http://yoursitehere/management-and-the-frozen-lake-and-how-coffee-helps/</link>
      <pubDate>Mon, 08 Sep 2014 20:49:30 &#43;0000</pubDate>
      
      <guid>http://yoursitehere/management-and-the-frozen-lake-and-how-coffee-helps/</guid>
      <description>

&lt;p&gt;It’s winter, and you’ve gone out for a walk. You’ve already passed the shops and an occasional snowman. You smile, briefly, but carry on. In front of you there should be a lake - you’re convinced there should be a lake - but it looks frosty, dull, and blends into its surroundings. You doubt yourself, perhaps it isn’t a lake after all?&lt;/p&gt;

&lt;p&gt;You carry on walking - happy that you can get home sooner. It’s cold out here, and the warmth of home seems far away, you’re in a hurry. Something doesn’t feel right, it sounds a bit crunchier than land, not quite what you’d expect - but you think what the hell, if it looks like land, and it works like land, it must be land. So you continue - you reason with yourself that it’s probably too late to go back now anyway.&lt;/p&gt;

&lt;p&gt;After a few minutes, you think you’re getting close. So close you can see home, you can nearly feel it. The tingly cold feeling slowly replaced with tingly warm. Then all of a sudden, it’s gone! Air replaced with water, your vision of home with one of drowning, anxiety and death. It seems it wasn’t land after all.&lt;/p&gt;

&lt;p&gt;Months later, following an expensive rescue operation and a long stay in hospital, you’re back home - everything seems fine now, winter has gone and the lake is definitely back (you’ve checked, its water!).&lt;/p&gt;

&lt;p&gt;You begin to remember falling in the lake, and soon have a realisation. You’ve fallen in the lake every year - and you keep on doing it! What’s even stranger - you hear of lots of other people doing it too. Somehow, you’ve adapted to ignoring the ice, falling in the lake, and you hadn’t even noticed.&lt;/p&gt;

&lt;p&gt;You wonder to yourself, why isn’t everyone falling in the lake? They have the same environment, the same hats, gloves and scarves. Why aren’t they getting wet? How are they getting home? They must just be lucky.&lt;/p&gt;

&lt;h2 id=&#34;so-why-are-some-people-just-so-damn-lucky:66c9f5edc1b53f9bbedb45111bdff41f&#34;&gt;So why are some people just so damn lucky?&lt;/h2&gt;

&lt;p&gt;Now it’s winter again - you’ve nipped out for your annual walk to wherever. But this year, on your way back, you try something a bit different. You’ve walked past the shops, and the snowmen, but you stop. You buy a coffee. There’s a bench - it’s cold, but you’ve wrapped up warm and you’re in no hurry. It’d be nice to be home, but you don’t really want to spend another few months in hospital.&lt;/p&gt;

&lt;p&gt;So you wipe away the snow, take a seat, and sip at your coffee, burning your lips, then pretending to “smoke”. Ahh, how relaxing.&lt;/p&gt;

&lt;p&gt;After just a few minutes, someone walks past. They’re in a hurry - you don’t know (or care) why. They get to where you thought the lake should be. They pause for a moment, then carry on - they’ve got somewhere to be. But you don’t follow - besides, you’ve still got some coffee left, and the bench feels a lot warmer than when you got here!&lt;/p&gt;

&lt;p&gt;You don’t have to wait long until a few more people walk past, and they all hurry off in the same direction.&lt;/p&gt;

&lt;p&gt;After a longer wait (though probably still not that long, your coffee is definitely still hot!), you spot something a bit unusual. Someone has got to where the lake should be, but they’ve stopped. How bizarre, you think to yourself, and take another sip of your coffee.&lt;/p&gt;

&lt;p&gt;You see them crouch down, and hear a small scraping noise. It’s a bit too dark to see what they’re doing, but you watch patiently anyway. Unexpectedly, they stand up, turn around, backtrack a few steps, and walk off in a completely different direction. You’re confused, nobody else has done that, but most importantly, you still have coffee.&lt;/p&gt;

&lt;p&gt;As time passes, you see more and more people walk past. Some of them stop, crouch down, then walk off in different directions. But most of them carry on walking - they’re in too much of a hurry to stop, or even consider taking the longer route. It is cold after all - they seen the weather warnings, but they weren’t prepared enough for this.&lt;/p&gt;

&lt;p&gt;Your coffee’s gone. Damnit, but at least you’re warmed up a bit for the walk home. Just as you stand up you hear a scream (definitely sounded like those people you seen earlier), a deafening crack, and a very wet sounding splash. You see a crack rip towards the shore, and the ice disappears into the water below.&lt;/p&gt;

&lt;p&gt;You walk off, with a grin on your face - clearly pleased with yourself - and you make it home. A little later than expected, but sooner than last year! You didn’t follow the others, you did something different too, and although the results weren’t immediate they were definitely worth waiting for.&lt;/p&gt;

&lt;h2 id=&#34;uh-seriously-what:66c9f5edc1b53f9bbedb45111bdff41f&#34;&gt;Uh, seriously&amp;hellip; what?&lt;/h2&gt;

&lt;p&gt;I think I enjoyed writing that way too much - but there is a serious point to be made.&lt;/p&gt;

&lt;p&gt;Over time, organisations and businesses can become frozen lakes. Managers and employees become the people and the fish, separated by thick, unbreakable ice. And although the results can occasionally be spectacular, the dangers are hidden, and often overlooked or massively underestimated.&lt;/p&gt;

&lt;p&gt;And the solution is to repeat the same mistakes, use the same broken logic and failing communication mechanisms which created exactly the problem we’re trying to solve. And somehow we forget, or remember inaccurately, and do it again and again.&lt;/p&gt;

&lt;h2 id=&#34;so-what-does-it-all-mean:66c9f5edc1b53f9bbedb45111bdff41f&#34;&gt;So what does it all mean?&lt;/h2&gt;

&lt;p&gt;Your perspective on this will depend on your position in your organisation.&lt;/p&gt;

&lt;p&gt;The higher up in management you are, the more like the “people” you are. You can hurry out onto the ice, oblivious to the precarious situation you’re in, and all you see is a distorted reflection of your surroundings, everything just looks “kind of ok”. One wrong move, disaster for you - wait too long, disaster for you and the fish!&lt;/p&gt;

&lt;p&gt;And lower down, you’re more like the “fish” - or whichever lake-dwelling animal you prefer. You can clearly see the danger, it’s the overpowering dullness above you, but you’re powerless to help. You’re trapped - you need air, but the surface is unreachable. You can scream as much as you can - but the ice, as well as hiding danger, is an effective sound barrier, and nobody hears a thing. And even if they did, they’re in too much of a hurry to notice.&lt;/p&gt;

&lt;p&gt;But you saw in the story, some people got home - they didn’t make the same mistakes, they didn’t get wet. And they even helped a few fish along the way.&lt;/p&gt;

&lt;p&gt;So what did they do differently? Why didn’t they make the same mistake? And how did they help those damn fish?&lt;/p&gt;

&lt;h2 id=&#34;you-need-to-gently-break-the-ice-metaphorically-speaking:66c9f5edc1b53f9bbedb45111bdff41f&#34;&gt;You need to gently break the ice, metaphorically speaking&lt;/h2&gt;

&lt;p&gt;Those people you seen crouching down - they weren’t “managers”.&lt;/p&gt;

&lt;p&gt;They were leaders.&lt;/p&gt;

&lt;p&gt;And that’s a significant difference!&lt;/p&gt;

&lt;p&gt;They were scratching away at the surface - digging deeper and deeper into the ice. Of course, they wanted to serve their own purpose, to find the dangers below to avoid them. But they went about it differently - and it had a side effect, one even they weren’t expecting. They cut a hole in the ice, and a lucky few fish got the air they desperately needed.&lt;/p&gt;

&lt;p&gt;Most importantly, instead of trusting that if it looks like ice, it must be ice, they took the initiative to check. And by checking for themselves, they found out that ice could be misleading. It could easily distort their view of the world, hiding dangers and increasing risks, despite the largest population (the fish) seeing things clearly.&lt;/p&gt;

&lt;p&gt;The same applies in organisations - and this is the mistake you made in the story. Year after year, despite repeating the same mistakes, and knowing their outcome, you used the same technique (“if it looks like ice”) to deliver the same failed results (expensive rescue and lengthy hospitalisation), then clearly remembered the technique and completely forgot the outcome. Ad infinitum.&lt;/p&gt;

&lt;p&gt;The leaders were different. They didn’t trust what worked before - especially since they knew it didn’t actually work last time - they slowed down, and found out for themselves, to avoid repeating the same mistakes again. They didn’t “ask the ice” what was happening below - they broke through it, went straight to the source, and got far clearer, and far more valuable information as a result. And helped a few fish survive of course!&lt;/p&gt;

&lt;h2 id=&#34;what-does-this-mean-for-me:66c9f5edc1b53f9bbedb45111bdff41f&#34;&gt;What does this mean for me?&lt;/h2&gt;

&lt;p&gt;As either a manager or employee, your view of the ice is similar - everything looks dull and bland, but kind of similar to how things look now (the distorted reflections and white dullness). The management-gap between employees and management is the “ice” - and the more levels of management there are, the thicker the ice, the more distorted the view, and the harder it is to break through, from either side.&lt;/p&gt;

&lt;p&gt;As a manager, particularly holding a senior position in an organisation, you should stop relying on (often) historical management structures to communicate with your employees. Go straight to the source - talk to them, spend time with them, and you’ll get a lot more back. Don’t ask the ice, break it.&lt;/p&gt;

&lt;p&gt;And if you’re near the top, don’t just help the fish near the top, help them all, even the ones right at the bottom. And I don’t mean every year either - I mean every day. Live with the fish if you have to - they provide the food that makes you what you are, protect them and care about them.&lt;/p&gt;

&lt;p&gt;It’ll be weird at first, and your employees might panic, but they’ll adjust. They’ll benefit too, but they’ll probably hate you until they can see it. That’s just tough, buy their temporary appreciation with nice toys if you have to - but work hard to earn their respect and trust, and in return you’ll get loyal, engaged and probably happy workers, who’ll back you up - even when you make mistakes.&lt;/p&gt;

&lt;h2 id=&#34;um-tell-me-a-bit-more-about-those-fish:66c9f5edc1b53f9bbedb45111bdff41f&#34;&gt;Um, tell me a bit more about those fish?&lt;/h2&gt;

&lt;p&gt;If you’re a fish, you have a lot to gain from this too. But often you’ll eventually lose. While the “people” have the power to harm you, it requires commitment and participation from both sides if we want to keep winning.&lt;/p&gt;

&lt;p&gt;You can just about survive when the people take the shortcut and smash the ice. It’s a turbulent few minutes, but as an uninjured fish, you’ll be fine again until next year.&lt;/p&gt;

&lt;p&gt;Some fish are unlucky - the annual strain gets too much, and eventually they die, or they sadly get their faces smashed in with a flying shard of ice (intensity intended… it happens to some employees, hopefully not literally speaking!). But however they go, they take with them some knowledge, or skill, which would ultimately benefit the school in warmer times.&lt;/p&gt;

&lt;p&gt;But when someone does break through the ice, even if only a tiny bit, you get air, a lifeline. It might not be much, but it helps repair just a bit of the damage - and now someone knows, maybe they’ll be able to help a bit more next year?&lt;/p&gt;

&lt;h2 id=&#34;and-what-s-this-about-coffee:66c9f5edc1b53f9bbedb45111bdff41f&#34;&gt;And what’s this about coffee?&lt;/h2&gt;

&lt;p&gt;The coffee is a metaphor for taking a break - sitting back and watching. See what people do. Don’t act. It’s far better to do the right thing later than do the wrong thing now, but sadly its too tempting to do the wrong thing now - the results come sooner, and often whether they’re good or bad is unimportant.&lt;/p&gt;

&lt;p&gt;Management stuck in the frozen lake cycle just need to take a break, stop intervening - let people do their jobs. And help them when they ask.&lt;/p&gt;

&lt;p&gt;If the fish ask for comically small pickaxes, and you just happen to have some (or can afford to buy some), help them, act quickly! They’re probably not crying wolf (or shark, perhaps?). And if they don’t ask, don’t give them anything - if you have to think they need it, then they probably don’t.&lt;/p&gt;

&lt;p&gt;But it &lt;strong&gt;ONLY&lt;/strong&gt; applies to management. Clearly fish can’t drink coffee.&lt;/p&gt;

&lt;p&gt;If you’re a fish (or an employee, as is more likely!), you need to do the exact opposite. You’re trapped, you can’t get air, and you’re going to die soon. And if you don’t die, you’ll need time to heal, time to rest, a long summer before the next cold winter. You could just go about your fishy business, but you can’t do that for long - one way or another, disaster is coming!&lt;/p&gt;

&lt;p&gt;So what can you do? Remember those tiny holes in the surface - the ones the leaders dug? Find them - scream and shout at them, don’t leave them alone. They’re the only ones who stand a chance of hearing you. And importantly, they’re up there - if they shout loud enough too, perhaps they can get other people to help - break apart the ice and save the fish, instead of just making sure they get home safe.&lt;/p&gt;

&lt;p&gt;Sadly, as in nature, it might not work. If the people are the top are tricked by the distorted reflection they see, and no leaders walk past to help, you’ll either have some sense of normalcy followed by a major blowout (highly likely), repeated consistently, or you’ll suffer and eventually die (thankfully far less likely).&lt;/p&gt;

&lt;h2 id=&#34;happily-ever-after:66c9f5edc1b53f9bbedb45111bdff41f&#34;&gt;Happily ever after&lt;/h2&gt;

&lt;p&gt;So I conclude my story about management and frozen lakes (and some snowmen, fish and a coffee).&lt;/p&gt;

&lt;p&gt;Disappointingly, there is no happily ever after. Not in this story, that’s something you’ll have to get over. Please don’t cry. Ok, cry - I’ll wait.&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;But there is a “happily for as long as we keep trying”. If the people keep digging and the fish keep screaming, there is some hope - and eventually you get home, warm and dry, and the fish get to live (albeit cold and wet). And you’re all better for it - you won’t make the same mistakes next year.&lt;/p&gt;

&lt;p&gt;Better still, you won’t even blindly walk around the lake next time - despite your commitment to remembering its a lake - because that won’t help the fish.&lt;/p&gt;

&lt;p&gt;Every year, from now on, you’ll stop, have a coffee, dig through the ice, and save the fish! And you can be happy knowing that everything is working just how it should - you’re sure it is, because the ice has gone and you can see clearly again.&lt;/p&gt;

&lt;p&gt;And although fish might not be able to scream, you can!&lt;/p&gt;

&lt;p&gt;(p.s. generally harassing your managers about stuff is as good as screaming - it’s quite possible that you’ll get escorted off the premises if you literally start screaming in work, and may end up in a mental hospital if you persist - be warned)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introducing Go-MailHog</title>
      <link>http://yoursitehere/introducing-go-mailhog/</link>
      <pubDate>Sun, 20 Apr 2014 16:36:34 &#43;0000</pubDate>
      
      <guid>http://yoursitehere/introducing-go-mailhog/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/ian-kent/Go-MailHog&#34;&gt;Go-MailHog&lt;/a&gt; is a lightweight portable application which acts like a SMTP server.&lt;/p&gt;

&lt;p&gt;It was inspired by &lt;a href=&#34;http://mailcatcher.me/&#34;&gt;MailCatcher&lt;/a&gt;, and does almost exactly the same thing, but without the slow and painful installation you get with Python Ruby.&lt;/p&gt;

&lt;p&gt;| edit: it was Ruby, not Python - but painful nonetheless!&lt;/p&gt;

&lt;p&gt;It was originally written in Perl based on code from &lt;a href=&#34;https://github.com/ian-kent/M3MTA&#34;&gt;M3MTA&lt;/a&gt;, but it&amp;rsquo;s been rewritten in Go for portability, and now runs on any supported platform without installation.&lt;/p&gt;

&lt;p&gt;MailHog is designed for testing emails during application development. Instead of using a real SMTP server which delivers messages or has strict rules on email recipients, you can use MailHog and send messages to any email address with a valid format.&lt;/p&gt;

&lt;p&gt;Instead of delivering the messages, they&amp;rsquo;re stored in MongoDB (edit: or memory!), and you can view them using the MailHog web interface, or retrieve them using an API for automated testing.&lt;/p&gt;

&lt;p&gt;Using MailHog is as simple as &lt;a href=&#34;https://github.com/ian-kent/Go-MailHog/releases&#34;&gt;downloading the binary release from GitHub&lt;/a&gt; and running it.&lt;/p&gt;

&lt;p&gt;With no configuration, it will listen on port 1025 for SMTP, 8025 for HTTP (both web and API), and will connect to MongoDB running on localhost port 27017.&lt;/p&gt;

&lt;p&gt;To view messages, point your browser at &lt;code&gt;http://localhost:8025&lt;/code&gt; or send a GET request to &lt;code&gt;http://localhost:8025/api/v1/messages&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://iankent.co.uk/wp-content/uploads/2014/04/MailHog.png&#34;&gt;&lt;img src=&#34;http://iankent.co.uk/wp-content/uploads/2014/04/MailHog.png&#34; alt=&#34;MailHog&#34; /&gt;
&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Action composition in Mojolicious</title>
      <link>http://yoursitehere/action-composition-in-mojolicious/</link>
      <pubDate>Sun, 20 Apr 2014 12:58:57 &#43;0000</pubDate>
      
      <guid>http://yoursitehere/action-composition-in-mojolicious/</guid>
      <description>

&lt;p&gt;Something about the routing in Mojolicious has been making things difficult, and Play Framework had the answer.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ian-kent/mojolicious-action-composition&#34;&gt;Full source code for these examples can be found on GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;routing-differences-in-play-framework-and-mojolicious:a3daa83d4d79bd93ea67944afafd2b47&#34;&gt;Routing differences in Play Framework and Mojolicious&lt;/h3&gt;

&lt;p&gt;It wasn&amp;rsquo;t obvious at first, but the routing model in Mojolicious quickly becomes an unfathomable mess - and very difficult to debug.&lt;/p&gt;

&lt;h4 id=&#34;mojolicious:a3daa83d4d79bd93ea67944afafd2b47&#34;&gt;Mojolicious&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Routes are complicated, can be chained together, and can have bridges and conditions which control the way routes behave:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Conditions are synchronous, and can switch between sub-routes on a per-request basis&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Bridges can be asynchronous, but always ultimately end at the same destination (e.g., you couldn&amp;rsquo;t have two identical routes running through different bridges, since Mojolicious couldn&amp;rsquo;t determine which to use or if a route even exists, which is why conditions are synchronous).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Controller actions are plain subs, called directly at run-time by the Mojolicious router&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Actions manipulate the stash and call Mojolicious methods directly (e.g. render)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The return value from an action is of limited use&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;play-framework:a3daa83d4d79bd93ea67944afafd2b47&#34;&gt;Play Framework:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Routes are simple - they&amp;rsquo;re written statically and have no concept of bridges or conditions.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;One route can point to one action, limited flexibility at the routing layer&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Actions are composed by nesting action functions, with outer functions calling inner functions&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The action returns either a result, or a future result&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Actions can choose to call other actions, or contain multiple nested actions inside one action&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;action-composition:a3daa83d4d79bd93ea67944afafd2b47&#34;&gt;Action composition&lt;/h3&gt;

&lt;p&gt;At first, the Play Framework routing model seemed very inflexible. Routes are static, and there&amp;rsquo;s no concept of bridges, conditions or any other way to intercept a request.&lt;/p&gt;

&lt;p&gt;With Mojolicious, bridges and chained routes make its easy to abstract the &amp;lsquo;how I get there&amp;rsquo; logic away from the &amp;lsquo;once I&amp;rsquo;ve got here&amp;rsquo; logic - and the Play Framework way of life didn&amp;rsquo;t seem to offer the same flexibility.&lt;/p&gt;

&lt;p&gt;Play Framework uses action composition, which means nesting actions inside other actions, and it felt a bit too restrictive.&lt;/p&gt;

&lt;p&gt;But action composition quickly proved to be the more powerful of the two. And definitely the easiest to understand, especially when tracing requests through a complicated web application.&lt;/p&gt;

&lt;h3 id=&#34;why-the-mojolicious-model-starts-well-but-ends-badly:a3daa83d4d79bd93ea67944afafd2b47&#34;&gt;Why the Mojolicious model starts well, but ends badly&lt;/h3&gt;

&lt;p&gt;The Mojolicious model is extremely powerful for a simple application - we can define route stubs or bridges, attach more routes to those, intercept requests in bridges and return 404 or 500 errors. Which is great - but then we end in a messy refactoring nightmare:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The code used in routing (e.g. authenticated bridges) needs to be shared between applications&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We move the code into a shared library, and get it to create named bridges&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We update our applications to use the named bridge from the shared library&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All good so far.&lt;/p&gt;

&lt;p&gt;Now we want to use a hook to intercept some part of the request - adding headers for example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;We write a plugin which registers a hook&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The hook adds custom headers to a response&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We include the plugin in our application, and all responses get new headers&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Still good. But once we&amp;rsquo;ve done this a few times, we end up with all routing and request manipulation being done by shared libraries. We have limited code visibility, and all we get to show for our efforts are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A few &lt;code&gt;-&amp;gt;plugin&lt;/code&gt; lines, adding &amp;lsquo;unknown&amp;rsquo; functionality to our routing&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$app-&amp;gt;plugin(&amp;lsquo;My::Magic::Routing::Plugin&amp;rsquo;);
$app-&amp;gt;plugin(&amp;lsquo;Another::Magic::Routing::Plugin&amp;rsquo;);
&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;An dangerous action sub, with no idea how the request gets there&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sub this_should_be_authenticated_and_authorised {
  $self-&amp;gt;delete_all_data;
  $self-&amp;gt;make_everyone_admin;
  $self-&amp;gt;enter_maintenance_mode;
  $self-&amp;gt;render(text =&amp;gt; &amp;lsquo;hope I really was authenticated&amp;hellip;&amp;rsquo;);
}
&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And now we&amp;rsquo;re potentially screwed.&lt;/p&gt;

&lt;p&gt;Mojolicious routing has become well hidden technical debt (or a serious defect/PR disaster) waiting to bite.&lt;/p&gt;

&lt;h3 id=&#34;why-the-play-framework-model-is-better:a3daa83d4d79bd93ea67944afafd2b47&#34;&gt;Why the Play Framework model is better&lt;/h3&gt;

&lt;p&gt;Although routing becomes far more static in Play Framework, we can still refactor our routing code into shared libraries.&lt;/p&gt;

&lt;p&gt;But there&amp;rsquo;s one important difference.&lt;/p&gt;

&lt;p&gt;With Play Framework action composition, we maintain full code visibility at the controller:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Authenticated { request =&amp;gt;
  Authorised(request, request.user) {
    Ok(request.user.get)
  } otherwise {
    Unauthorized
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of tracing through multiple plugins to find out what happens to a request, it&amp;rsquo;s all there in front of us. We know the request is Authenticated, and is then Authorised. If we have a bug, its easy to follow a request to see what happens.&lt;/p&gt;

&lt;p&gt;We can also choose how much code visibility we get - for example, Authenticated takes care of what happens if user authentication fails, but Authorised leaves it to the developer to decide how to handle an authorisation failure.&lt;/p&gt;

&lt;h3 id=&#34;so-what-can-we-do-about-it:a3daa83d4d79bd93ea67944afafd2b47&#34;&gt;So what can we do about it&lt;/h3&gt;

&lt;p&gt;This is Perl - there&amp;rsquo;s always a way!&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s define the syntax first:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;# a plain action
Action &#39;welcome&#39; =&amp;gt; sub {
  shift-&amp;gt;render(text =&amp;gt; &#39;&#39;);
};

# an asynchronous action (without a render_later call)
Action &#39;login&#39; =&amp;gt; Async {
  my $self = shift;
  Mojo::IOLoop-&amp;gt;timer(0.25 =&amp;gt; sub {
    $self-&amp;gt;render(text =&amp;gt; &#39;&#39;);
  });
};

# an authenticated action
Action &#39;private1&#39; =&amp;gt; Authenticated {
  shift-&amp;gt;render(text =&amp;gt; &#39;&#39;);
};

# nested actions, with parameters
Action &#39;private2&#39; =&amp;gt; Async { Authenticated {
  WithPermission &#39;blog.post&#39; =&amp;gt; sub {
    shift-&amp;gt;render(text =&amp;gt; &#39;&#39;);
  }, sub {
    shift-&amp;gt;render(text =&amp;gt; &#39;not authorised&#39;);
  }
}};
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;implementing-it-in-mojolicious:a3daa83d4d79bd93ea67944afafd2b47&#34;&gt;Implementing it in Mojolicious&lt;/h3&gt;

&lt;p&gt;To start with, we need a way to define an action. This is essentially the same as the default sub{}, but lets us capture its contents.&lt;/p&gt;

&lt;h4 id=&#34;the-basic-action-action:a3daa83d4d79bd93ea67944afafd2b47&#34;&gt;The basic Action action&lt;/h4&gt;

&lt;p&gt;We need to be able to pass in a sub, and return a sub (though, for the top-level Action, we&amp;rsquo;ll need to monkey patch it so the Mojolicious router can find it).&lt;/p&gt;

&lt;p&gt;Since we need to be able to chain these actions together, we also need to recursively call the inner action. We&amp;rsquo;ll also need to do that for any other actions we define, so lets make it generic:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;sub go {
  my ($controller, $inner) = @_;
  my $i = $inner;
  while($i) {
    my $res = $i-&amp;gt;($controller) if ref($i) eq &#39;CODE&#39;;
    $i = ref($res) eq &#39;CODE&#39; ? $res : undef;
  }
  return undef;
}

sub Action($$) {
  my ($action, $inner) = @_;
  monkey_patch caller, $action =&amp;gt; sub { go(shift, $inner) }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is enough to let us define a new action like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;Action &#39;myaction&#39; =&amp;gt; sub {
    shift-&amp;gt;render(text =&amp;gt; &#39;&#39;);
};
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;a-nested-action-async:a3daa83d4d79bd93ea67944afafd2b47&#34;&gt;A nested action - Async&lt;/h4&gt;

&lt;p&gt;Adding another action type is just as easy.&lt;/p&gt;

&lt;p&gt;Since Async is our first &amp;lsquo;nested&amp;rsquo; action, we&amp;rsquo;ll implement that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;sub Async(&amp;amp;) {
  my $inner = shift;
  return sub {
    my $controller = shift;
    $controller-&amp;gt;render_later;
    go($controller, $inner);
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can define an Async action, without needing to call &lt;code&gt;render_later&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;Action &#39;login&#39; =&amp;gt; Async {
  my $self = shift;
  Mojo::IOLoop-&amp;gt;timer(0.25 =&amp;gt; sub {
    $self-&amp;gt;session(auth =&amp;gt; 1);
    $self-&amp;gt;render(text =&amp;gt; &#39;&#39;);
  });
};
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;an-action-with-parameters:a3daa83d4d79bd93ea67944afafd2b47&#34;&gt;An action with parameters&lt;/h4&gt;

&lt;p&gt;We&amp;rsquo;ll skip over the Authenticated action for now - its almost identical to Async, with the exception of needing to perform a session lookup to decide whether to continue the action chain.&lt;/p&gt;

&lt;p&gt;Instead, we&amp;rsquo;ll implement WithPermission - an action with run-time parameters.&lt;/p&gt;

&lt;p&gt;We need to be able to pass in some custom parameters, and a sub, and have it return a sub which, like the others, invokes the inner sub when its called:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;sub WithPermission($&amp;amp;;&amp;amp;) {
  my ($permission, $inner, $error) = @_;
  return sub {
    my $controller = shift;
    if($permission eq &#39;blog.delete&#39;) {
      go($controller, $inner);
    } else {
      $error ? go($controller, $error) : $controller-&amp;gt;render_exception(&#39;Unauthorised&#39;);
    }
    return undef;
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which lets us define an action like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;Action &#39;private1&#39; =&amp;gt; Authenticated { WithPermission &#39;blog.post&#39; =&amp;gt; sub {
  shift-&amp;gt;render(text =&amp;gt; &#39;&#39;);
}, sub {
  shift-&amp;gt;render(text =&amp;gt; &#39;need permission blog.post&#39;);
}};
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the user is authenticated and has the permission &amp;lsquo;blog.post&amp;rsquo;, the first inner action gets executed, otherwise the second is called instead. However, since our WithPermission action only accepts &amp;lsquo;blog.delete&amp;rsquo;, this will always fail.&lt;/p&gt;

&lt;p&gt;The WithPermission action also implements a default failure action, so we could skip the second inner action completely.&lt;/p&gt;

&lt;h3 id=&#34;summary:a3daa83d4d79bd93ea67944afafd2b47&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;The simple implementation above gives us the flexibility to move our bridge and condition code away from the routing and into the controller layer, improving code visibility for developers.&lt;/p&gt;

&lt;p&gt;We can get many of the benefits that Play Framework offers, but there&amp;rsquo;s still one big difference.&lt;/p&gt;

&lt;p&gt;In Play Framework, we could invoke an action and inspect its result, and still choose to not return that content to the user. This gives us the flexibility to invoke multiple actions, and decide later which to use, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Authenticated { request =&amp;gt;
  val res1 = Foo(request);
  val res2 = Bar(request);
  if((res1.body.json \ &#39;some_key&#39;).isDefined)
    Authorised(res1, request.user) {
  else
    Unauthorized
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Mojolicious, the client might end up with a mixture of both responses, or just whichever gets called first. Because Mojolicious doesn&amp;rsquo;t use the return value, as soon as an action calls &lt;code&gt;-&amp;gt;render&lt;/code&gt; it will immediately return a response to the client.&lt;/p&gt;

&lt;p&gt;It should be possible - by creating a new stash and fake response objects, and possibly patching &lt;code&gt;-&amp;gt;render&lt;/code&gt; - to trick Mojolicious into supporting a future/promise based interface.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Getting started with HashiCorp Serf</title>
      <link>http://yoursitehere/getting-started-with-hashicorp-serf/</link>
      <pubDate>Thu, 27 Feb 2014 22:53:03 GMT</pubDate>
      
      <guid>http://yoursitehere/getting-started-with-hashicorp-serf/</guid>
      <description>

&lt;p&gt;In my &lt;a href=&#34;http://iankent.co.uk/2014/02/26/a-quick-introduction-to-apache-mesos/&#34;&gt;post about Apache Mesos&lt;/a&gt; I briefly mentioned Serf.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.serfdom.io&#34;&gt;Serf&lt;/a&gt; (from &lt;a href=&#34;http://www.hashicorp.com/&#34;&gt;Hashicorp&lt;/a&gt;, who also make &lt;a href=&#34;http://www.vagrantup.com&#34;&gt;Vagrant&lt;/a&gt; and &lt;a href=&#34;http://www.packer.io/&#34;&gt;Packer&lt;/a&gt;) is a decentralised service discovery tool with support for custom events.&lt;/p&gt;

&lt;p&gt;By installing a Serf agent on each node in a network, and (maybe) bootstrapping each agent with the IP address of another agent, you are quickly provided with a scalable membership system with the ability to propagate events across the network.&lt;/p&gt;

&lt;p&gt;Once it&amp;rsquo;s installed and agents are started, running &lt;code&gt;serf members&lt;/code&gt; from any node will produce output similar to this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;vagrant@master10:~$ serf members
master10     192.168.100.131:7946    alive    role=master
zk10     192.168.100.130:7946    alive    role=zookeeper
slave10     192.168.100.135:7946    alive    role=slave
mongodb10     192.168.100.136:7946    alive    role=mongodb
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which is when you realise you&amp;rsquo;ve still got a Mesos cluster running that you&amp;rsquo;d forgotten about&amp;hellip;&lt;/p&gt;

&lt;p&gt;The output from Serf shows the hostname, IP address, status and any tags the Serf agent is configured with. In this case, I&amp;rsquo;ve set a &lt;code&gt;role&lt;/code&gt; tag which lets us quickly find a particular instance type on the network:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;vagrant@master10:~$ serf members | grep mongodb
mongodb10     192.168.100.136:7946    alive    role=mongodb
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This, with its event system, makes Serf ideal for efficiently maintaining cluster node state, and reducing or eliminating application configuration.&lt;/p&gt;

&lt;p&gt;In a Mesos cluster, it lets us make core parts of the infrastructure (like ZooKeepers and Mesos masters) simple to scale with no manual configuration.&lt;/p&gt;

&lt;p&gt;Serf has lots of other potential uses too, &lt;a href=&#34;http://www.serfdom.io/intro/use-cases.html&#34;&gt;some of them documented on the Serf website&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;getting-started-with-serf:9ebde56991c3197de5edd6f179dc2fd9&#34;&gt;Getting started with Serf&lt;/h2&gt;

&lt;h3 id=&#34;installation:9ebde56991c3197de5edd6f179dc2fd9&#34;&gt;Installation&lt;/h3&gt;

&lt;p&gt;Installing Serf couldn&amp;rsquo;t be easier.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.serfdom.io/downloads.html&#34;&gt;Download Serf&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Extract the downloaded archive&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Move the &amp;lsquo;serf&amp;rsquo; binary into your PATH (&lt;a href=&#34;http://www.serfdom.io/intro/getting-started/install.html&#34;&gt;full instructions from Serf&lt;/a&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You should be able to run &lt;code&gt;serf&lt;/code&gt; from the command line and see a list of available commands.&lt;/p&gt;

&lt;h3 id=&#34;trying-it-out:9ebde56991c3197de5edd6f179dc2fd9&#34;&gt;Trying it out&lt;/h3&gt;

&lt;p&gt;To try Serf, you need two console windows open and you&amp;rsquo;re ready!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Run &lt;code&gt;serf agent&lt;/code&gt; from one console&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Run &lt;code&gt;serf members&lt;/code&gt; from another&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You should see something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;vagrant@example:~$ serf members
example     127.0.0.1:7946    alive
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That output shows a cluster containing your local machine (with a hostname of &amp;lsquo;example&amp;rsquo;), available at 127.0.0.1, and that the node is alive.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s that simple!&lt;/p&gt;

&lt;h2 id=&#34;starting-serf-automatically:9ebde56991c3197de5edd6f179dc2fd9&#34;&gt;Starting Serf automatically&lt;/h2&gt;

&lt;p&gt;This isn&amp;rsquo;t much use on its own - we need Serf to start every time a node boots up. As soon as a new node comes online, the cluster finds out about it immediately, and the new node can configure itself.&lt;/p&gt;

&lt;p&gt;Serf provides us with &lt;a href=&#34;https://github.com/hashicorp/serf/tree/master/ops-misc&#34;&gt;example scripts for upstart and systemd&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For Ubuntu, copy &lt;code&gt;upstart.conf&lt;/code&gt; to &lt;code&gt;/etc/init/serf-agent.conf&lt;/code&gt; then run &lt;code&gt;start serf-agent&lt;/code&gt; (you might need to modify the upstart script if Serf isn&amp;rsquo;t installed to &lt;code&gt;/usr/local/bin/serf&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&#34;configuration:9ebde56991c3197de5edd6f179dc2fd9&#34;&gt;Configuration&lt;/h3&gt;

&lt;p&gt;Now we&amp;rsquo;ve got our Serf agent running, we need to configure it so it knows what to do.&lt;/p&gt;

&lt;p&gt;You can configure Serf using either command line options (useful if you&amp;rsquo;re talking to a remote Serf agent or using non-standard ports), or you can provide configuration files (which are JSON files, loaded from the configuration directory in alphabetical order).&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;ve used the Ubuntu upstart script, creating &lt;code&gt;config.json&lt;/code&gt; in &lt;code&gt;/etc/serf&lt;/code&gt; will work.&lt;/p&gt;

&lt;p&gt;All of the configuration options are &lt;a href=&#34;http://www.serfdom.io/docs/agent/options.html&#34;&gt;documented on the Serf website&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The examples below are in JSON, but they can all be provided as command line arguments instead.&lt;/p&gt;

&lt;h4 id=&#34;ip-addresses:9ebde56991c3197de5edd6f179dc2fd9&#34;&gt;IP addresses&lt;/h4&gt;

&lt;p&gt;This caught me out a few times - Serf, by default, will advertise the bind address (usually the IP address of your first network interface, e.g. eth0).&lt;/p&gt;

&lt;p&gt;In a Vagrant environment, you will always have a NAT connection as your first interface (the one Vagrant uses to communicate with the VM). This was causing my agents to advertise an IP which other nodes couldn&amp;rsquo;t connect to.&lt;/p&gt;

&lt;p&gt;To fix this, Serf lets us override the IP address it advertises to the cluster:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;{
    &amp;quot;advertise&amp;quot;: &amp;quot;192.168.100.200&amp;quot;
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;setting-tags:9ebde56991c3197de5edd6f179dc2fd9&#34;&gt;Setting tags&lt;/h4&gt;

&lt;p&gt;Serf used to provide a &amp;lsquo;role&amp;rsquo; command line option (it still does, but its deprecated). In its place, we have tags, which are far more flexible.&lt;/p&gt;

&lt;p&gt;Tags are key-value pairs which provide metadata about the agent. In the example above, I&amp;rsquo;ve created a tag named &lt;code&gt;role&lt;/code&gt; which describes the purpose of the node.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;{
    &amp;quot;tags&amp;quot;: {
        &amp;quot;role&amp;quot;: &amp;quot;mongodb&amp;quot;
    }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can set multiple tags, but there is a limit - the Serf documentation doesn&amp;rsquo;t specify the limit, except to say&lt;/p&gt;

&lt;blockquote&gt;
  
&gt; 
&gt; There is a byte size limit for the maximum number of tags, but in practice dozens of tags may be used.
&gt; 
&gt; 
&lt;/blockquote&gt;

&lt;p&gt;You can also &lt;a href=&#34;http://www.serfdom.io/docs/commands/tags.html&#34;&gt;replace tags while the Serf agent is still running&lt;/a&gt; using the &lt;code&gt;serf tags&lt;/code&gt; command, though changes aren&amp;rsquo;t persisted to configuration files.&lt;/p&gt;

&lt;h4 id=&#34;protocol:9ebde56991c3197de5edd6f179dc2fd9&#34;&gt;Protocol&lt;/h4&gt;

&lt;p&gt;You shouldn&amp;rsquo;t need to set the protocol - it should default to the latest version (currently 3).&lt;/p&gt;

&lt;p&gt;It does, when started from the command line. But it didn&amp;rsquo;t seem to when started using upstart and a configuration directory. Easy to fix though:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;{
    &amp;quot;protocol&amp;quot;: 3
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This might not be a bad practice anyway, you can update Serf on all nodes without worrying about protocol compatibility.&lt;/p&gt;

&lt;h4 id=&#34;forming-a-cluster:9ebde56991c3197de5edd6f179dc2fd9&#34;&gt;Forming a cluster&lt;/h4&gt;

&lt;p&gt;I&amp;rsquo;ll cover this in more detail later, but you can set either &lt;code&gt;start_join&lt;/code&gt; or &lt;code&gt;discover&lt;/code&gt; to join your agent to a cluster.&lt;/p&gt;

&lt;h3 id=&#34;scripting-it:9ebde56991c3197de5edd6f179dc2fd9&#34;&gt;Scripting it&lt;/h3&gt;

&lt;p&gt;Since Serf is ideal for a cloud environment, its useful to script its installation and configuration.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example using bash &lt;a href=&#34;https://github.com/ian-kent/vagrant-mongodb/blob/master/Vagrantfile&#34;&gt;similar to the one in my vagrant-mongodb example&lt;/a&gt;. It installs Serf, configures upstart, and writes an example JSON configuration file.&lt;/p&gt;

&lt;p&gt;Because its from a Vagrant build, it uses a workaround to find the correct IP.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;wget https://dl.bintray.com/mitchellh/serf/0.4.5_linux_amd64.zip
unzip 0.4.5_linux_amd64.zip
mv serf /usr/local/bin
rm 0.4.5_linux_amd64.zip
wget https://raw.github.com/hashicorp/serf/c15b5f15dec3d735dae1a6d1f3455d4d7b5685e7/ops-misc/upstart.conf
mv upstart.conf /etc/init/serf-agent.conf
mkdir /etc/serf
ip=`ip addr list eth1 | grep &amp;quot;inet &amp;quot; | cut -d &#39; &#39; -f6 | cut -d/ -f1`
echo { \&amp;quot;start_join\&amp;quot;: [\&amp;quot;$1\&amp;quot;], \&amp;quot;protocol\&amp;quot;: 3, \&amp;quot;tags\&amp;quot;: { \&amp;quot;role\&amp;quot;: \&amp;quot;mongodb\&amp;quot; }, \&amp;quot;advertise\&amp;quot;: \&amp;quot;$ip\&amp;quot; } | tee /etc/serf/config.json
exec start serf-agent
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;forming-a-cluster-1:9ebde56991c3197de5edd6f179dc2fd9&#34;&gt;Forming a cluster&lt;/h2&gt;

&lt;p&gt;So far we have just a single Serf agent. The next step is to setup another Serf agent, and join them together, forming a (small) cluster of Serf agents.&lt;/p&gt;

&lt;h4 id=&#34;using-multicast-dns-mdns:9ebde56991c3197de5edd6f179dc2fd9&#34;&gt;Using multicast DNS (mDNS)&lt;/h4&gt;

&lt;p&gt;Serf supports multicast DNS, so in a contained environment with multicast support we don&amp;rsquo;t need to provide it with a neighbour.&lt;/p&gt;

&lt;p&gt;Using the &lt;code&gt;discover&lt;/code&gt; configuration option, we provide Serf with a cluster name which it will use to automatically discover Serf peers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;{
    &amp;quot;discover&amp;quot;: &amp;quot;mycluster&amp;quot;
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In a cloud environment this removes the need to bootstrap Serf, making it truly autonomous.&lt;/p&gt;

&lt;h4 id=&#34;providing-a-neighbour:9ebde56991c3197de5edd6f179dc2fd9&#34;&gt;Providing a neighbour&lt;/h4&gt;

&lt;p&gt;If we can&amp;rsquo;t use multicast DNS, we can provide a neighbour and Serf will discover the rest of the cluster from there.&lt;/p&gt;

&lt;p&gt;This could be problematic, but if we&amp;rsquo;re in a Mesos cluster it becomes easy. We know at least one Zookeeper must always be available, so we can give Serf the hostnames of our known Zookeeper instances:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;{
    &amp;quot;start_join&amp;quot;: [ &amp;quot;zk1&amp;quot;, &amp;quot;zk2&amp;quot;, &amp;quot;zk3&amp;quot; ]
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, if we get the Zookeepers to update a load balancer (using Serf!) when they join or leave the cluster, we can make our configuration even easier:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;{
    &amp;quot;start_join&amp;quot;: [ &amp;quot;zk&amp;quot; ]
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can also use the same technique to configure Serf on the Zookeeper nodes.&lt;/p&gt;

&lt;h3 id=&#34;how-clusters-are-formed:9ebde56991c3197de5edd6f179dc2fd9&#34;&gt;How clusters are formed&lt;/h3&gt;

&lt;p&gt;A cluster is formed as soon as one agent discovers another (whether this is through multicast DNS or using a known neighbour).&lt;/p&gt;

&lt;p&gt;As soon as a cluster is formed, agents will share information between them using the &lt;a href=&#34;http://www.serfdom.io/docs/internals/gossip.html&#34;&gt;Gossip Protocol&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If agents from two existing clusters discover each other, the two clusters will become a single cluster. Full membership information is propagated to every node.&lt;/p&gt;

&lt;p&gt;Once two clusters have merged, it would be difficult to split them without restarting all agents in the cluster or forcing agents to leave the cluster using the &lt;code&gt;force-leave&lt;/code&gt; command (and preventing them from discovering each other again!).&lt;/p&gt;

&lt;h2 id=&#34;nodes-leaving:9ebde56991c3197de5edd6f179dc2fd9&#34;&gt;Nodes leaving&lt;/h2&gt;

&lt;p&gt;If a node chooses to leave the cluster (e.g. scaling down or restarting nodes), other nodes in the cluster will be informed with a &lt;code&gt;leave&lt;/code&gt; event.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s membership information will be updated to show a &amp;lsquo;left&amp;rsquo; state:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;example     192.168.100.200:7946    left    role=mongodb
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A node leaving the cluster is treated differently to a failure.&lt;/p&gt;

&lt;p&gt;This is determined by the signal sent to the Serf agent to terminate the process. An &lt;code&gt;interrupt&lt;/code&gt; signal (Ctrl+C or &lt;code&gt;kill -2&lt;/code&gt;) will tell the node to leave the cluster, while a &lt;code&gt;kill&lt;/code&gt; signal (&lt;code&gt;kill -9&lt;/code&gt;) will be treated as a node failure.&lt;/p&gt;

&lt;h2 id=&#34;node-failures:9ebde56991c3197de5edd6f179dc2fd9&#34;&gt;Node failures&lt;/h2&gt;

&lt;p&gt;When a node fails, other nodes are informed with a &lt;code&gt;failed&lt;/code&gt; event.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s membership information will be updated to show a &amp;lsquo;failed&amp;rsquo; state:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;example     192.168.100.200:7946    failed    role=mongodb
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Knowledge of the failed node is kept by other Serf agents in the cluster. They will periodically attempt to reconnect to the node, and eventually remove the node if further attempts are unsuccessful.&lt;/p&gt;

&lt;h2 id=&#34;events:9ebde56991c3197de5edd6f179dc2fd9&#34;&gt;Events&lt;/h2&gt;

&lt;p&gt;Serf uses events to propagate membership information across the cluster, either &lt;code&gt;member-join&lt;/code&gt;, &lt;code&gt;member-leave&lt;/code&gt;, &lt;code&gt;member-failed&lt;/code&gt; or &lt;code&gt;member-update&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can also send custom events (which use the &lt;code&gt;user&lt;/code&gt; event type), and provide a custom event name and data payload to send with it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;serf event dosomething &amp;quot;{ \&amp;quot;foo\&amp;quot;: \&amp;quot;bar\&amp;quot; }&amp;quot;
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Events with the same name within a short time frame are coalesced into one event, although this can be disabled using the &lt;code&gt;-coalesce=false&lt;/code&gt; command line argument.&lt;/p&gt;

&lt;p&gt;This makes Serf useful as an automation tool - for example, to install applications on cluster nodes or configure ZooKeeper or Mesos instances.&lt;/p&gt;

&lt;h3 id=&#34;event-handlers:9ebde56991c3197de5edd6f179dc2fd9&#34;&gt;Event handlers&lt;/h3&gt;

&lt;p&gt;Event handlers are scripts which are executed as a shell command in response to the events.&lt;/p&gt;

&lt;h4 id=&#34;shell-environment:9ebde56991c3197de5edd6f179dc2fd9&#34;&gt;Shell environment&lt;/h4&gt;

&lt;p&gt;Within the shell created by Serf, we have the following environment variables available:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;SERF_EVENT&lt;/code&gt; - the event type&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;SERF_SELF_NAME&lt;/code&gt; - the current node name&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;SERF_SELF_ROLE&lt;/code&gt; - the role of the node, but presumably deprecated&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;SERF_TAG_${TAG}&lt;/code&gt; - one for each tag set (uppercased)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;SERF_USER_EVENT&lt;/code&gt; - the user event type, if SERF_EVENT is &amp;lsquo;user&amp;rsquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;SERF_USER_LTIME&lt;/code&gt; - the &lt;a href=&#34;http://en.wikipedia.org/wiki/Lamport_timestamps&#34;&gt;Lamport timestamp&lt;/a&gt; of the event, if SERF_EVENT is &amp;lsquo;user&amp;rsquo;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Any data payload given by the event is piped to STDIN.&lt;/p&gt;

&lt;h4 id=&#34;creating-event-handlers:9ebde56991c3197de5edd6f179dc2fd9&#34;&gt;Creating event handlers&lt;/h4&gt;

&lt;p&gt;Serf&amp;rsquo;s event handler syntax is quite flexible, and lets you listen to all events or filter based on event type.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The most basic option is to invoke a script for every event:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{
    &amp;ldquo;event_handlers&amp;rdquo;: [
        &amp;ldquo;dosomething.sh&amp;rdquo;
    ]
}
&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can listen for a specific event type:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{
    &amp;ldquo;event_handlers&amp;rdquo;: [
        &amp;ldquo;member-join=dosomething.sh&amp;rdquo;
    ]
}
&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can specify multiple event types:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{
    &amp;ldquo;event_handlers&amp;rdquo;: [
        &amp;ldquo;member-join,member-leave=dosomething.sh&amp;rdquo;
    ]
}
&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can listen to just user events:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{
    &amp;ldquo;event_handlers&amp;rdquo;: [
        &amp;ldquo;user=dosomething.sh&amp;rdquo;
    ]
}
&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can listen for specific user event types:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{
    &amp;ldquo;event_handlers&amp;rdquo;: [
        &amp;ldquo;user:dosomething=dosomething.sh&amp;rdquo;
    ]
}
&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Multiple event handlers can be specified, and all event handlers which match for an event will be invoked.&lt;/p&gt;

&lt;h2 id=&#34;reloading-configuration:9ebde56991c3197de5edd6f179dc2fd9&#34;&gt;Reloading configuration&lt;/h2&gt;

&lt;p&gt;Serf can reload its configuration without restarting the agent.&lt;/p&gt;

&lt;p&gt;To do this, send a &lt;code&gt;SIGHUP&lt;/code&gt; signal to the Serf process, for example using &lt;code&gt;killall serf -HUP&lt;/code&gt; or &lt;code&gt;kill -1 PID&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You could even use custom user events to rewrite Serf configuration files and reload them across the entire cluster.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A quick introduction to Apache Mesos</title>
      <link>http://yoursitehere/a-quick-introduction-to-apache-mesos/</link>
      <pubDate>Wed, 26 Feb 2014 19:01:35 GMT</pubDate>
      
      <guid>http://yoursitehere/a-quick-introduction-to-apache-mesos/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://mesos.apache.org/&#34;&gt;Apache Mesos&lt;/a&gt; is a centralised fault-tolerant cluster manager. It&amp;rsquo;s designed for distributed computing environments to provide resource isolation and management across a cluster of slave nodes.&lt;/p&gt;

&lt;p&gt;In some ways, Mesos provides the opposite to virtualisation:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Virtualisation splits a single physical resource into multiple virtual resources&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Mesos joins multiple physical resources into a single virtual resource&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It schedules CPU and memory resources across the cluster in much the same way the Linux Kernel schedules local resources.&lt;/p&gt;

&lt;p&gt;A Mesos cluster is made up of four major components:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ZooKeepers&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Mesos masters&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Mesos slaves&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Frameworks&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;zookeeper:d12db87a3f4ce64d7023ff8451a41464&#34;&gt;ZooKeeper&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://zookeeper.apache.org/&#34;&gt;Apache ZooKeeper&lt;/a&gt; is a centralised configuration manager, used by distributed applications such as Mesos to coordinate activity across a cluster.&lt;/p&gt;

&lt;p&gt;Mesos uses ZooKeeper to elect a leading master and for slaves to join the cluster.&lt;/p&gt;

&lt;h3 id=&#34;mesos-masters:d12db87a3f4ce64d7023ff8451a41464&#34;&gt;Mesos masters&lt;/h3&gt;

&lt;p&gt;A Mesos master is a Mesos instance in control of the cluster.&lt;/p&gt;

&lt;p&gt;A cluster will typically have multiple Mesos masters to provide fault-tolerance, with one instance elected the leading master.&lt;/p&gt;

&lt;h3 id=&#34;mesos-slaves:d12db87a3f4ce64d7023ff8451a41464&#34;&gt;Mesos slaves&lt;/h3&gt;

&lt;p&gt;A Mesos slave is a Mesos instance which offers resources to the cluster.&lt;/p&gt;

&lt;p&gt;They are the &amp;lsquo;worker&amp;rsquo; instances - tasks are allocated to the slaves by the Mesos master.&lt;/p&gt;

&lt;h3 id=&#34;frameworks:d12db87a3f4ce64d7023ff8451a41464&#34;&gt;Frameworks&lt;/h3&gt;

&lt;p&gt;On its own, Mesos only provides the basic &amp;ldquo;kernel&amp;rdquo; layer of your cluster. It lets other applications request resources in the cluster to perform tasks, but does nothing itself.&lt;/p&gt;

&lt;p&gt;Frameworks bridge the gap between the Mesos layer and your applications. They are higher level abstractions which simplify the process of launching tasks on the cluster.&lt;/p&gt;

&lt;h4 id=&#34;chronos:d12db87a3f4ce64d7023ff8451a41464&#34;&gt;Chronos&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/airbnb/chronos&#34;&gt;Chronos&lt;/a&gt; is a cron-like fault-tolerant scheduler for a Mesos cluster.&lt;/p&gt;

&lt;p&gt;You can use it to schedule jobs, receive failure and completion notifications, and trigger other dependent jobs.&lt;/p&gt;

&lt;h4 id=&#34;marathon:d12db87a3f4ce64d7023ff8451a41464&#34;&gt;Marathon&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mesosphere/marathon&#34;&gt;Marathon&lt;/a&gt; is the equivalent of the Linux upstart or init daemons, designed for long-running applications.&lt;/p&gt;

&lt;p&gt;You can use it to start, stop and scale applications across the cluster.&lt;/p&gt;

&lt;h4 id=&#34;others:d12db87a3f4ce64d7023ff8451a41464&#34;&gt;Others&lt;/h4&gt;

&lt;p&gt;There are a few other frameworks:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://aurora.apache.org/&#34;&gt;Aurora&lt;/a&gt; - service scheduler&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://hadoop.apache.org/&#34;&gt;Hadoop&lt;/a&gt; - data processing&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/jenkinsci/mesos-plugin&#34;&gt;Jenkins&lt;/a&gt; - Jenkins slave manager&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://spark.apache.org/&#34;&gt;Spark&lt;/a&gt; - data processing&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.adaptivecomputing.com/products/open-source/torque/&#34;&gt;Torque&lt;/a&gt; - resource manager&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can also &lt;a href=&#34;http://mesos.apache.org/documentation/latest/&#34;&gt;write your own framework&lt;/a&gt;, using Java, Python or C++.&lt;/p&gt;

&lt;h2 id=&#34;the-quick-start-guide:d12db87a3f4ce64d7023ff8451a41464&#34;&gt;The quick start guide&lt;/h2&gt;

&lt;p&gt;If you want to get a Mesos cluster up and running, you have a few options:&lt;/p&gt;

&lt;h3 id=&#34;using-vagrant:d12db87a3f4ce64d7023ff8451a41464&#34;&gt;Using Vagrant&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.vagrantup.com&#34;&gt;Vagrant&lt;/a&gt; and the &lt;a href=&#34;https://github.com/everpeace/vagrant-mesos&#34;&gt;vagrant-mesos&lt;/a&gt; Vagrantfile can help you quickly build:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;a standalone Mesos instance&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;a multi-machine Mesos cluster of ZooKeepers, masters and slaves&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unfortunately, the network configuration is a bit difficult to work with - it uses a private network between the VMs, and SSH tunnelling to provide access to the cluster.&lt;/p&gt;

&lt;h3 id=&#34;using-mesosphere-and-amazon-web-services:d12db87a3f4ce64d7023ff8451a41464&#34;&gt;Using Mesosphere and Amazon Web Services&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://mesosphere.io/&#34;&gt;Mesosphere&lt;/a&gt; provide &lt;a href=&#34;https://elastic.mesosphere.io/&#34;&gt;Elastic Mesosphere&lt;/a&gt;, which can quickly launch a Mesos cluster using &lt;a href=&#34;http://aws.amazon.com/ec2/&#34;&gt;Amazon EC2&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This is far easier to work with than the Vagrant build, but it isn&amp;rsquo;t free - around $1.50 an hour for 6 instances or $4.50 for 18.&lt;/p&gt;

&lt;h3 id=&#34;a-simpler-vagrant-build:d12db87a3f4ce64d7023ff8451a41464&#34;&gt;A simpler Vagrant build&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve put together some Vagrantfiles to build individual components of a Mesos cluster. It&amp;rsquo;s a work in progress, but it can already build a working Mesos cluster without the networking issues. It uses bridged networking, with dynamically assigned IPs, so all instances can be accessed directly through your local network.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll need the following GitHub repositories:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/ian-kent/vagrant-zookeeper&#34;&gt;ian-kent/vagrant-zookeeper&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/ian-kent/vagrant-mesos-master&#34;&gt;ian-kent/vagrant-mesos-master&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/ian-kent/vagrant-mesos-slave&#34;&gt;ian-kent/vagrant-mesos-slave&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;At the moment, a cluster is limited to one ZooKeeper, but can support multiple Mesos masters and slaves.&lt;/p&gt;

&lt;p&gt;Each of the instances is also built with &lt;a href=&#34;http://serfdom.io&#34;&gt;Serf&lt;/a&gt; to provide decentralised service discovery. You can use &lt;code&gt;serf members&lt;/code&gt; from any instance to list all other instances.&lt;/p&gt;

&lt;p&gt;To help test deployments, there&amp;rsquo;s also a MongoDB build with Serf installed:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ian-kent/vagrant-mongodb&#34;&gt;ian-kent/vagrant-mongodb&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Like the ZooKeeper instances, the MongoDB instance joins the same Serf cluster but isn&amp;rsquo;t part of the Mesos cluster.&lt;/p&gt;

&lt;h2 id=&#34;once-your-cluster-is-running:d12db87a3f4ce64d7023ff8451a41464&#34;&gt;Once your cluster is running&lt;/h2&gt;

&lt;p&gt;You&amp;rsquo;ll need to install a framework.&lt;/p&gt;

&lt;p&gt;Mesosphere lets you choose to install Marathon on Amazon EC2, so that could be a good place to start.&lt;/p&gt;

&lt;p&gt;Otherwise, manually installing and configuring Marathon or another framework is easy. The quick and dirty way is to install them on the Mesos masters, but it would be better if they had their own VMs.&lt;/p&gt;

&lt;p&gt;With Marathon or Aurora, you can even run other frameworks in the Mesos cluster for scalability and fault-tolerance.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The automation what-for</title>
      <link>http://yoursitehere/the-automation-what-for/</link>
      <pubDate>Tue, 25 Feb 2014 21:23:04 GMT</pubDate>
      
      <guid>http://yoursitehere/the-automation-what-for/</guid>
      <description>

&lt;p&gt;Today, our developers and testers were asked to justify the use of test automation - a surprising question after we&amp;rsquo;ve invested 5 years in writing automated test cases.&lt;/p&gt;

&lt;p&gt;The challenge was to prove the value in continuing to automate our test cases, on the basis that it should be up to scrutiny if the value really does exist.&lt;/p&gt;

&lt;h4 id=&#34;so-we-tried:0ce8429d54ada539b10abd45c7aa53e0&#34;&gt;So we tried&amp;hellip;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Automated tests are repeatable and consistent&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Automated tests and testing platforms can be easily scaled as the code base grows&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Automated tests can be executed concurrently against many environments&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Automated tests can provide rapid feedback on system/code changes&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;of-course-the-same-isn-t-true-for-manual-testing:0ce8429d54ada539b10abd45c7aa53e0&#34;&gt;Of course, the same isn&amp;rsquo;t true for manual testing&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Manual tests can be unpredictable&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;different testers may produce different results&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;testers may use workarounds to avoid some bugs&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Manual testing isn&amp;rsquo;t scalable - employing more people is the only option&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;An individual tester can only (sensibly) test one environment at a time&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Manual tests are slow - feedback might take days, weeks or months&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;but-these-weren-t-the-right-answers:0ce8429d54ada539b10abd45c7aa53e0&#34;&gt;But these weren&amp;rsquo;t the right answers.&lt;/h3&gt;

&lt;p&gt;We couldn&amp;rsquo;t understand why.&lt;/p&gt;

&lt;p&gt;So, lets have a closer look at automation&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;what-is-automation:0ce8429d54ada539b10abd45c7aa53e0&#34;&gt;What is automation?&lt;/h2&gt;

&lt;p&gt;Automation, by definition, is:&lt;/p&gt;

&lt;blockquote&gt;
  
&gt; 
&gt; the technique, method, or system of operating or controlling a process by highly automatic means, as by electronic devices, reducing human intervention to a minimum
&gt; 
&gt; 
&lt;/blockquote&gt;

&lt;p&gt;Originally used circa 1940, the word was an irregular formation combining &amp;ldquo;automatic&amp;rdquo; and &amp;ldquo;action&amp;rdquo;, but process automation had become a well established practice long before then.&lt;/p&gt;

&lt;p&gt;Everything from manufacturing and agriculture to construction and transportation - in modern history, humans have automated nearly every aspect of their lives.&lt;/p&gt;

&lt;p&gt;On an industrial scale the benefits are immediately obvious. A farmer wouldn&amp;rsquo;t employ manual labour to plough fields any more than a car manufacturer would employ manual labour to assemble cars.&lt;/p&gt;

&lt;p&gt;The return on investment (ROI) for the automation of these processes is clear - though of course it wasn&amp;rsquo;t in the decades leading up to the industrial revolution.&lt;/p&gt;

&lt;h2 id=&#34;why-do-we-automate-things:0ce8429d54ada539b10abd45c7aa53e0&#34;&gt;Why do we automate things?&lt;/h2&gt;

&lt;p&gt;There are many reasons to automate processes - some are purely economic while others are psychological.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Simple or boring tasks (paying bills)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Time consuming tasks (washing dishes)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Beyond our physical capability (lifting shipping containers)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To reduce cost (human labour)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To reduce risk (bomb disposal robots)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In all cases, our ability to automate something is limited by our mental capacity to perform that task. We can only automate the things we understand, that are simple enough and repeatable enough. We can&amp;rsquo;t easily automate tasks requiring creativity or emotion.&lt;/p&gt;

&lt;p&gt;For example, we can easily automate opening a shop door (we &lt;em&gt;could&lt;/em&gt; do it manually), but we would find it difficult to automate brain surgery (most humans couldn&amp;rsquo;t do it even manually) or software engineering (many have tried).&lt;/p&gt;

&lt;p&gt;But sometimes, even when a process can be automated, we decide not to.&lt;/p&gt;

&lt;h2 id=&#34;why-do-we-choose-not-to-automate-things:0ce8429d54ada539b10abd45c7aa53e0&#34;&gt;Why do we choose not to automate things?&lt;/h2&gt;

&lt;p&gt;Just as there are some processes we would like to automate, but can&amp;rsquo;t - there are some processes we could automate, but don&amp;rsquo;t:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Things we enjoy doing&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Economic cost, e.g. R&amp;amp;D investment is too high or unpredictable&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Social cost, e.g. unemployment and poverty&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Like our ability to automate is limited by our mental capacity to perform a task, our ability to choose not to automate is equally limited by our physical limitations in performing a task (we wouldn&amp;rsquo;t even consider using human labour to lift a shipping container).&lt;/p&gt;

&lt;h1 id=&#34;how-we-decide-what-to-automate:0ce8429d54ada539b10abd45c7aa53e0&#34;&gt;How we decide what to automate&lt;/h1&gt;

&lt;p&gt;Deciding whether we automate a process comes down to a cost-benefit analysis, determining if the investment required (whether an economic, physical or psychological investment) is worth the benefit we get in return.&lt;/p&gt;

&lt;p&gt;As with all cost-benefit analysis, the time-frame over which we calculate the costs and benefits can have a considerable impact on the ROI.&lt;/p&gt;

&lt;p&gt;For example, if Ford had only planned to make 1000 cars over a 2 year time frame, then it would be obvious that the ROI on designing, building, testing and deploying an automated car manufacturing process would be terrible, and would probably result in a net loss (or bankruptcy) for the company.&lt;/p&gt;

&lt;p&gt;But if Ford wanted to continue producing cars - maybe another &lt;a href=&#34;http://www.autoblog.com/2012/08/31/ford-focus-is-companys-350th-millionth-vehicle-and-worlds-best/&#34;&gt;350 million cars over a 109 years&lt;/a&gt; - then the ROI becomes far more appealing.&lt;/p&gt;

&lt;p&gt;Although the up-front investment in research and development is high, the long-term benefit of this is exponentially higher, ultimately making Ford one of the world&amp;rsquo;s leading car manufacturers and forging the modern automotive industry.&lt;/p&gt;

&lt;h2 id=&#34;why-software-testing-is-no-different:0ce8429d54ada539b10abd45c7aa53e0&#34;&gt;Why software testing is no different&lt;/h2&gt;

&lt;p&gt;Just like agriculture and manufacturing, automating software testing comes with a high initial (and sometimes on-going) cost:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Developers and testers need to learn how to write automated tests&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Test suites need to be written and maintained&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;An automated testing platform must be created&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And just like agriculture and manufacturing, some of it doesn&amp;rsquo;t need automation (or can&amp;rsquo;t be automated):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If it&amp;rsquo;s throwaway/one-use code&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Exploratory testing which requires creativity&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Visual testing (does it look/feel right)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But in most cases, well written automated tests provide a level of confidence unmatched by manual testing:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Entire system components can be updated or replaced efficiently&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Codebases can be safely refactored&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Integration and release can be automated&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Fixed defects can&amp;rsquo;t regress&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;More platforms can be tested (desktop, web, mobile, etc)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;By developing an automated testing suite, testing resources can then be reallocated to more productive work:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Improving test coverage&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Collaborating with developers&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Exploratory and visual testing&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Accessibility testing&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;so-what-was-the-answer:0ce8429d54ada539b10abd45c7aa53e0&#34;&gt;So, what was the answer?&lt;/h2&gt;

&lt;p&gt;It certainly won&amp;rsquo;t be &amp;ldquo;because we should&amp;rdquo; or &amp;ldquo;it&amp;rsquo;s the right thing to do&amp;rdquo;, or even &amp;ldquo;it&amp;rsquo;ll reduce defects&amp;rdquo; or &amp;ldquo;it&amp;rsquo;ll improve code quality&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;It will come down to proving, through cost-benefit analysis, that the investment in automated testing provides a strong enough ROI. This will largely depend on the time frame used for the ROI calculation.&lt;/p&gt;

&lt;p&gt;If the focus is short-term (&amp;ldquo;we want a great product now&amp;rdquo;) then any further investment in test automation will yield no value, and manual testing is the only choice.&lt;/p&gt;

&lt;p&gt;But if the focus is long-term (&amp;ldquo;we still want a great product in 5 years&amp;rdquo;) then test automation is invaluable (supplemented with appropriate manual testing), and provably so in any cost-benefit analysis.&lt;/p&gt;

&lt;h3 id=&#34;is-there-a-middle-ground:0ce8429d54ada539b10abd45c7aa53e0&#34;&gt;Is there a middle ground?&lt;/h3&gt;

&lt;p&gt;The middle ground does seem attractive:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Manual testing to get a quick delivery&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Automate tests longer-term&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It seems to promise a good short and long term ROI. We get our quick delivery, to an acceptable standard. We also get our test automation. And eventually we get a high quality product.&lt;/p&gt;

&lt;p&gt;But until the test automation happens, developers are constrained by the existing codebase:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;refactoring becomes difficult or impossible&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;updating components carries significant risk&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;minor changes, bug fixes and features take an inordinate amount of time to develop, test and deploy&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This has a substantial consequence for the product or service being delivered:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If test automation never happens (no time is made available), the entire product will suffer and eventually adding new features or fixing bugs will become impossible&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If test automation happens (quickly), new features will be held up while test suites are automated, delaying the creation of business value&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Either way, the middle ground eventually becomes technical debt, and the short term business value gained through a reduction in the initial investment must eventually be repaid (through reduced longer-term value).&lt;/p&gt;

&lt;h2 id=&#34;a-cost-benefit-analysis:0ce8429d54ada539b10abd45c7aa53e0&#34;&gt;A cost-benefit analysis&lt;/h2&gt;

&lt;p&gt;Many cost-benefit analysis of test automation have already been carried out, so I&amp;rsquo;m not going to write &amp;ldquo;Yet Another Cost-Benefit Analysis&amp;rdquo; - but here&amp;rsquo;s a few links instead:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.softwarequalitymethods.com/papers/star99%20model%20paper.pdf&#34;&gt;Cost Benefits Analysis of Test Automation&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.ibm.com/developerworks/rational/library/content/RationalEdge/dec02/TestAutomation_TheRationalEdge_Dec2002.pdf&#34;&gt;The Business Argument for Investing in Test Automation&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.automatedtestinginstitute.com/home/index.php?option=com_content&amp;amp;id=58&amp;amp;Itemid=65&#34;&gt;Return on Investment (ROI) Calculator&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://wiki.directi.com/download/attachments/1703938/Automated+Testing+vs+Manual+Testing.ppt&#34;&gt;Automated Testing vs Manual Testing&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;conclusion:0ce8429d54ada539b10abd45c7aa53e0&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Given the historical importance of process automation throughout the industrial revolution, the rapid improvement to standards of living that we&amp;rsquo;re still benefiting from today, and the significant expansion of the human race as a result of the earliest technological automation, it seems counter-intuitive to even question the value in automating software testing.&lt;/p&gt;

&lt;p&gt;Though I agree that some tests shouldn&amp;rsquo;t be automated (or can&amp;rsquo;t be), when products or services are expected to have a long &amp;ldquo;shelf-life&amp;rdquo;, test automation becomes the only sensible solution.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also important to consider the human element in any cost-benefit analysis.&lt;/p&gt;

&lt;p&gt;Testers and developers, like anyone else, get bored easily when tasked with simple and repetitive work. If we have the opportunity to automate this work, we leave humans with the more complex and creative work - the stuff we&amp;rsquo;re really good at, the stuff that we can&amp;rsquo;t automate, and the stuff that&amp;rsquo;s just more satisfying to do.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building a scalable sequence generator (in Scala)</title>
      <link>http://yoursitehere/building-a-scalable-sequence-generator-in-scala/</link>
      <pubDate>Sun, 23 Feb 2014 11:53:37 GMT</pubDate>
      
      <guid>http://yoursitehere/building-a-scalable-sequence-generator-in-scala/</guid>
      <description>

&lt;p&gt;Building a scalable sequence generator was more difficult than I&amp;rsquo;d anticipated.&lt;/p&gt;

&lt;h3 id=&#34;the-challenge:1488174a7a6bea43933aad3fecc4c536&#34;&gt;The challenge&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Build a scalable sequence generator (must scale out and provide resilience)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Master sequence number is stored in MongoDB, updated atomically using find and modify&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sequence numbers must never be repeated (but strict ordering isn&amp;rsquo;t required)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;the-problem:1488174a7a6bea43933aad3fecc4c536&#34;&gt;The problem&lt;/h3&gt;

&lt;p&gt;Since the sequence number is a single value stored in a single document in a single collection, the document gets locked on every request. MongoDB can&amp;rsquo;t help with scaling:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Starting multiple instances of our sequence generator doesn&amp;rsquo;t help, they all need to lock the same document&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Multiple MongoDB nodes doesn&amp;rsquo;t help - we&amp;rsquo;d need &lt;a href=&#34;http://docs.mongodb.org/manual/core/write-concern/#replica-acknowledged&#34;&gt;replica acknowledged write concern&lt;/a&gt; to avoid duplicate sequence numbers&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;the-solution:1488174a7a6bea43933aad3fecc4c536&#34;&gt;The solution&lt;/h3&gt;

&lt;p&gt;The solution is to take batches of sequence numbers from MongoDB, multiplying the scalability - for example, using a batch size of 10 means we can run (approximately) 10 instances of our sequence generator to our 1 MongoDB document, though any instance failure could waste up to 10 sequence numbers.&lt;/p&gt;

&lt;p&gt;Using batches also dramatically improves our performance - we make far fewer MongoDB requests, generating less network traffic and reducing service response times.&lt;/p&gt;

&lt;h4 id=&#34;the-unscalable-sequence-generator:1488174a7a6bea43933aad3fecc4c536&#34;&gt;The unscalable sequence generator&lt;/h4&gt;

&lt;p&gt;Building an unscalable sequence generator is easy. We can just find and modify the next sequence, MongoDB takes care of the rest.&lt;/p&gt;

&lt;p&gt;An implementation might look a bit like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;object UnscalableSequenceGenerator extends App {
  // the master sequence number
  var seq = 0

  def nextSeq : Future[Int] = future { blocking {
    // pretend we&#39;re doing a find and modify asynchronously
    Thread.sleep(30)
    this.synchronized {
      seq = seq + 1
      seq
    }
  } }

  // simulate calling our HTTP service 100 times
  for(i &amp;lt;- 1 to 100) {
    nextSeq map { j =&amp;gt;
      // pretend we&#39;re doing something useful with the sequence number
      print(s&amp;quot;$j &amp;quot;)
      if(i % 10 == 0) println
    }
  }

  Thread.sleep(5000)
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running that example produces output like this (the exact ordering of numbers may be different):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;2 3 1 4 5 7 6 8 9 10 11 12 
14 13 16 17 15 19 18 21 22 20 24 23 25 
26 27 28 30 29 
31 32 34 33 36 35 37 38 39 40 41 43 42 
44 46 45 47 48 49 50 51 52 
53 55 54 56 57 58 60 59 
62 61 63 64 65 66 67 68 69 70 
71 72 74 73 75 76 78 77 80 79 81 
82 83 85 84 86 87 89 88 90 91 
93 95 92 96 97 94 99 98 100 
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No duplicates, but it&amp;rsquo;s not scalable, and the performance is terrible.&lt;/p&gt;

&lt;h4 id=&#34;making-it-scalable:1488174a7a6bea43933aad3fecc4c536&#34;&gt;Making it scalable&lt;/h4&gt;

&lt;p&gt;To make it scalable (and get a performance boost), we can use sequence number batches. But that turned out to be more difficult than I&amp;rsquo;d expected.&lt;/p&gt;

&lt;p&gt;The first attempt looked a bit like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;object BatchedSequenceGenerator extends App {
  // the master sequence number and batch size
  var seq = 0
  val batch_size = 10

  // our current sequence and maximum sequence numbers
  var local_seq = 0
  var local_max = 0

  def newBatch : Future[Int] = future { blocking {
    // pretend we&#39;re doing a find and modify asynchronously
    Thread.sleep(30)
    this.synchronized {
        seq = seq + 10
        seq
    }
  } }

  def nextSeq : Future[Int] = {
    if(local_seq &amp;gt;= local_max) {
      // Get a new batch of sequence numbers
      newBatch map { new_max =&amp;gt;
        // Update our local sequence
        local_max = new_max
        local_seq = local_max - batch_size
        local_seq = local_seq + 1
        local_seq
      }
    } else {
      // Use our local sequence number
      val next_seq = local_seq
      local_seq = local_seq + 1
      future { next_seq }
    }
  }

  // simulate calling our HTTP service 100 times
  for(i &amp;lt;- 1 to 100) nextSeq map { j =&amp;gt;
    // pretend we&#39;re doing something useful with the sequence number
    print(s&amp;quot;$j &amp;quot;)
    if(i % 10 == 0) println
  }

  Thread.sleep(5000)
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While it does at least take batches of sequence numbers, we get the following unexpected but understandable output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;11 1 41 61 71 91 21 31 121 181 191 131 141 151 161 171 201 211 221 
101 81 111 51 
231 251 241 261 271 281 291 301 
311 321 331 341 351 361 371 381 
391 401 411 421 441 431 451 461 471 
481 491 501 511 521 531 541 551 
561 571 581 591 601 611 621 631 641 651 661 671 681 701 701 731 731 721 
741 751 761 791 781 771 801 811 821 831 841 
861 871 851 881 891 911 
901 921 931 951 961 941 971 
991 981
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;re only using 1/10th of each batch, and we get to 991 in only 100 requests. It&amp;rsquo;s no more scalable than the unbatched version.&lt;/p&gt;

&lt;p&gt;It should probably have been obvious, but the problem is caused by requests arriving between requesting a new batch and getting a response:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The 10th request gives out the last local sequence number&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The 11th request gets a new batch asynchronously&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The 12th request arrives before we get a new batch, and requests another new batch asynchronously&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We get the 11th request batch, reset our sequence numbers and return a sequence&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We get the 12th request batch, and again reset our sequence numbers and return a sequence, wasting the rest of the previous batch&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To fix it, we need the 12th request to wait for the 11th request to complete first.&lt;/p&gt;

&lt;h4 id=&#34;making-it-work:1488174a7a6bea43933aad3fecc4c536&#34;&gt;Making it work&lt;/h4&gt;

&lt;p&gt;This was the tricky bit - implementing it led me down a road of endless compiler errors, but the idea was simple.&lt;/p&gt;

&lt;p&gt;When we call &lt;code&gt;nextSeq&lt;/code&gt;, we need to know if a new batch request is pending. If it is, instead of requesting a new batch, we need to wait for the existing request to complete, otherwise handle the request as normal.&lt;/p&gt;

&lt;p&gt;We can do this by chaining futures together, keeping track of whether a batch request is currently in progress.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s a fairly simple change to our batched sequence generator (or at least, in hindsight it is):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;object BatchedSequenceGenerator extends App {
  // the master sequence number and batch size
  var seq = 10
  val batch_size = 10

  // our current sequence and maximum sequence numbers
  var local_seq = 0
  var local_max = 10
  var pending : Option[Future[Int]] = None

  def newBatch : Future[Int] = future { blocking {
    // pretend we&#39;re doing a find and modify asynchronously
    Thread.sleep(30)
    this.synchronized {
      seq = seq + batch_size
      seq
    }
  } }

  def nextSeq : Future[Int] = this.synchronized {
    pending match {
      case None =&amp;gt;
        if(local_seq &amp;gt;= local_max) {
          // Get a new batch of sequence numbers
          pending = Some(newBatch map { new_max =&amp;gt;
            // Update our local sequence
            local_max = new_max
            local_seq = local_max - batch_size + 1
            local_seq
          })
          // Clear the pending future once we&#39;ve got the batch
          pending.get andThen { case _ =&amp;gt; pending = None }
        } else {
          // Use our local sequence number
          local_seq = local_seq + 1
          val seq = local_seq
          future(seq)
        }
      case Some(f) =&amp;gt;
        // Wait on the pending future
        f flatMap { f =&amp;gt; nextSeq }
    }
  }

  // simulate calling our HTTP service 100 times
  for(i &amp;lt;- 1 to 100) nextSeq map { j =&amp;gt;
    // pretend we&#39;re doing something useful with the sequence number
    print(s&amp;quot;$j &amp;quot;)
    if(i % 10 == 0) println
  }

  Thread.sleep(5000)
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And running that example generates output like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;3 5 6 2 7 8 9 10 
4 1 13 11 12 14 15 17 19 20 
16 18 23 21 24 26 27 28 29 30 22 
25 34 35 31 33 37 38 39 40 
32 36 45 41 44 46 47 48 43 
49 50 42 52 53 55 51 60 54 56 
57 58 59 62 
64 70 63 61 65 66 67 68 69 72 75 71 
73 74 76 77 78 80 79 82 83 85 84 86 87 81 
89 88 90 92 95 93 99 98 100 97 
96 91 94 
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The changes we made are straightforward:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;When we request a new sequence number, check if a pending future exists&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If it does, wait on that and return a new call to nextSeq&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If not, check if a new batch is required&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If it is, store the future before returning&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It not, use the existing batch as normal&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A limitation of this approach - if we have a sufficiently small batch size with a high volume of requests, the considerable number of chained futures could potentially cause out of memory errors.&lt;/p&gt;

&lt;p&gt;Getting it to work felt like an achievement, but I&amp;rsquo;m still not happy with the code. It looks like there should be a nicer way to do it, and it doesn&amp;rsquo;t feel all that functional, but I can&amp;rsquo;t see it yet!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Quick start with Perl and Mojolicious</title>
      <link>http://yoursitehere/quick-start-with-perl-and-mojolicious/</link>
      <pubDate>Fri, 14 Feb 2014 14:43:20 GMT</pubDate>
      
      <guid>http://yoursitehere/quick-start-with-perl-and-mojolicious/</guid>
      <description>&lt;p&gt;To get started with &lt;a href=&#34;http://www.mojolicio.us&#34;&gt;Mojolicious&lt;/a&gt;, just as quick and dirty as with &lt;a href=&#34;//iankent.co.uk/2014/02/13/quick-start-with-scala-and-play-framework/&#34;&gt;Scala and Play Framework&lt;/a&gt;, you need only these:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://vagrantup.com&#34;&gt;Vagrant&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.virtualbox.org/&#34;&gt;VirtualBox&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://git-scm.com/download/win&#34;&gt;Git for Windows&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once they&amp;rsquo;re all installed, its this easy:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Open Git Bash&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Clone my &lt;a href=&#34;https://github.com/ian-kent/vagrant-perl-mojolicious-mongodb&#34;&gt;Mojolicious/Perl vagrant repository&lt;/a&gt;: &lt;code&gt;git clone https://github.com/ian-kent/vagrant-perl-mojolicious-mongodb.git mojoserver&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Change directory: &lt;code&gt;cd mojoserver&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Start the virtual machine: &lt;code&gt;vagrant up&lt;/code&gt; (might take a while, installing Perl is slow!)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Once it&amp;rsquo;s complete, connect using SSH: &lt;code&gt;vagrant ssh&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Create a new Mojolicious app: &lt;code&gt;mojo generate app MyApp&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Change directory: &lt;code&gt;cd my_app&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Start your application: &lt;code&gt;./script/my_app daemon&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;View your new Mojolicious site in a browser: &lt;code&gt;http://localhost:3000&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It installs the latest version of &lt;a href=&#34;http://mojolicio.us&#34;&gt;Mojolicious&lt;/a&gt; and &lt;a href=&#34;http://mojolicio.us/perldoc/Mango&#34;&gt;Mango&lt;/a&gt; along with Perl 5.18.2 and &lt;a href=&#34;http://cpanmin.us&#34;&gt;cpanminus&lt;/a&gt; using Perlbrew.&lt;/p&gt;

&lt;p&gt;To help you get started, the Vagrantfile also installs &lt;a href=&#34;http://www.mongodb.org/&#34;&gt;MongoDB&lt;/a&gt; and sets up port forwarding for port 3000 and 8080 (Mojolicious with Morbo and Hypnotoad) and port 27017 (MongoDB)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Quick start with Scala and Play Framework</title>
      <link>http://yoursitehere/quick-start-with-scala-and-play-framework/</link>
      <pubDate>Thu, 13 Feb 2014 19:23:23 GMT</pubDate>
      
      <guid>http://yoursitehere/quick-start-with-scala-and-play-framework/</guid>
      <description>&lt;p&gt;For the quick and dirty way to get &lt;a href=&#34;http://www.playframework.com/&#34;&gt;Play Framework&lt;/a&gt; up and running, you need only these:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://vagrantup.com&#34;&gt;Vagrant&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.virtualbox.org/&#34;&gt;VirtualBox&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://git-scm.com/download/win&#34;&gt;Git for Windows&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once they&amp;rsquo;re all installed, its this easy:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Open Git Bash&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Clone my &lt;a href=&#34;https://github.com/ian-kent/vagrant-scala-play-mongodb&#34;&gt;Play/Scala vagrant repository&lt;/a&gt;: &lt;code&gt;git clone https://github.com/ian-kent/vagrant-scala-play-mongodb.git playserver&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Change directory: &lt;code&gt;cd playserver&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Start the virtual machine: &lt;code&gt;vagrant up&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Once it&amp;rsquo;s complete, connect using SSH: &lt;code&gt;vagrant ssh&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Create a new play app: &lt;code&gt;play new MyApp&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Change directory: &lt;code&gt;cd MyApp&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Start your application: &lt;code&gt;play run&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;View your new Play site in a browser: &lt;code&gt;http://localhost:9000&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you want to edit your Play project in &lt;a href=&#34;http://www.jetbrains.com/idea/&#34;&gt;IntelliJ Idea&lt;/a&gt;, create the project files from the command line using &lt;code&gt;play gen-idea&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To help you get started, the Vagrantfile also installs &lt;a href=&#34;http://www.mongodb.org/&#34;&gt;MongoDB&lt;/a&gt; and sets up port forwarding for port 9000 (Play) and port 27017 (MongoDB)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Globally handling OPTIONS requests in Play Framework</title>
      <link>http://yoursitehere/globally-handling-options-requests-in-play-framework/</link>
      <pubDate>Tue, 11 Feb 2014 21:38:30 GMT</pubDate>
      
      <guid>http://yoursitehere/globally-handling-options-requests-in-play-framework/</guid>
      <description>

&lt;p&gt;If you&amp;rsquo;re using AJAX to talk to a Play Framework application, you&amp;rsquo;ll probably need to respond to OPTIONS requests and might need to return the correct access control (CORS) headers.&lt;/p&gt;

&lt;p&gt;In a controller, we can easily define a handler to accept OPTIONS requests:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def headers = List(
  &amp;quot;Access-Control-Allow-Origin&amp;quot; -&amp;gt; &amp;quot;*&amp;quot;,
  &amp;quot;Access-Control-Allow-Methods&amp;quot; -&amp;gt; &amp;quot;GET, POST, OPTIONS, DELETE, PUT&amp;quot;,
  &amp;quot;Access-Control-Max-Age&amp;quot; -&amp;gt; &amp;quot;3600&amp;quot;,
  &amp;quot;Access-Control-Allow-Headers&amp;quot; -&amp;gt; &amp;quot;Origin, Content-Type, Accept, Authorization&amp;quot;,
  &amp;quot;Access-Control-Allow-Credentials&amp;quot; -&amp;gt; &amp;quot;true&amp;quot;
)

def options = Action { request =&amp;gt;
  NoContent.withHeaders(headers : _*)
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we can call our new options handler from our routes file, but this has a few problems. We either need to implement an options handler for every route, or we send the same response whatever route we have, even if it doesn&amp;rsquo;t exist.&lt;/p&gt;

&lt;h3 id=&#34;per-route:690e640b2fe5a8e8798609567de62b3e&#34;&gt;Per-route&lt;/h3&gt;

&lt;p&gt;If you want to respond on a per-route basis, that typically requires one additional line in your routes file for every route you define:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;GET / controllers.Application.index
OPTIONS / controllers.Application.options
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;globally:690e640b2fe5a8e8798609567de62b3e&#34;&gt;Globally&lt;/h3&gt;

&lt;p&gt;Or, if you don&amp;rsquo;t mind sending the same headers back for every OPTIONS request (even if the route doesn&amp;rsquo;t really exist), there&amp;rsquo;s a cheat:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;OPTIONS / controllers.Application.rootOptions
OPTIONS /*url controllers.Application.options(url: String)
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and change your controller options handler to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def rootOptions = options(&amp;quot;/&amp;quot;)   
def options(url: String) = Action { request =&amp;gt;
  NoContent.withHeaders(headers : _*)
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can still override the global OPTIONS per-route by adding additional routes before the wildcard, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;OPTIONS /foo controllers.Application.someCustomOptions
OPTIONS / controllers.Application.rootOptions
OPTIONS /*url controllers.Application.options(url: String)
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;or-we-can-abuse-play-framework-the-best-way:690e640b2fe5a8e8798609567de62b3e&#34;&gt;Or we can abuse Play Framework - the best way!&lt;/h3&gt;

&lt;p&gt;Play Framework doesn&amp;rsquo;t like to expose its routing, making it difficult to inspect the routing table once its been created. But it is possible! Doing that, we can globally handle OPTIONS requests but dynamically respond based on URL (or even other request parameters).&lt;/p&gt;

&lt;p&gt;For this example, we&amp;rsquo;ll work out the &lt;code&gt;Allow&lt;/code&gt; header so we can return a 204 response if the route would normally exist, but a 404 response if it wouldn&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;This is the example routes file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;GET /           controllers.Application.index
GET /foo        controllers.Application.foo
OPTIONS /       controllers.Application.rootOptions
OPTIONS /*url   controllers.Application.options(url: String)
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When sending OPTIONS requests, we want to respond with 204 and &lt;code&gt;Allow: GET, OPTIONS&lt;/code&gt; for &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;/foo&lt;/code&gt;, but respond with 404 for everything else.&lt;/p&gt;

&lt;h4 id=&#34;getting-the-methods-available-for-a-url:690e640b2fe5a8e8798609567de62b3e&#34;&gt;Getting the methods available for a URL&lt;/h4&gt;

&lt;p&gt;Play Framework gives us a convenient function - &lt;code&gt;handlerFor&lt;/code&gt; - which is normally used to route requests to a handler. For this to work, you&amp;rsquo;ll need to add an import:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;import play.api.Play.current
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then define a &lt;code&gt;getMethods&lt;/code&gt; function, which given a request will return a list of available methods. It does this by asking Play Framework to route new requests with modified method parameters. If a handler is found, the method is added to the list. The list is also cached for future requests.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;val methodList = List(&amp;quot;GET&amp;quot;, &amp;quot;POST&amp;quot;, &amp;quot;PUT&amp;quot;, &amp;quot;DELETE&amp;quot;, &amp;quot;PATCH&amp;quot;)
def getMethods(request: Request[AnyContent]) : List[String] = {
  Cache.getOrElse[List[String]](&amp;quot;options.url.&amp;quot; + request.uri) {
    for(m &amp;lt;- methodList; if Play.application.routes.get.handlerFor(new RequestHeader {
      val remoteAddress = request.remoteAddress
      val headers = request.headers
      val queryString = request.queryString
      val version = request.version
      val method = m
      val path = request.path
      val uri = request.uri
      val tags = request.tags
      val id: Long = request.id
    }).isDefined) yield m
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then update our options action to use the new method list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def options(url: String) = Action { request =&amp;gt;
  val methods = List(&amp;quot;OPTIONS&amp;quot;) ++ getMethods(request)
  if(methods.length &amp;gt; 1)
    NoContent.withHeaders(List(&amp;quot;Allow&amp;quot; -&amp;gt; methods.mkString(&amp;quot;, &amp;quot;)) : _*)
  else
    NotFound
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We add OPTIONS back in, and if we have more than one method we return the Allow header, otherwise a 404 response.&lt;/p&gt;

&lt;p&gt;We could instead cache the entire response for a given URI, but caching just the method list gives us the flexibility to set other headers which may be more dynamic, for example Last-Modified. Even the current caching might be too restrictive if the available methods depends on other request parameters.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Action composition in Play Framework</title>
      <link>http://yoursitehere/action-composition-in-play-framework/</link>
      <pubDate>Mon, 10 Feb 2014 16:32:47 GMT</pubDate>
      
      <guid>http://yoursitehere/action-composition-in-play-framework/</guid>
      <description>

&lt;p&gt;Action composition in Play Framework is an incredibly powerful way to enhance or restrict controller behaviour, for example to implement authentication or authorisation controls, set default headers, or handle OPTIONS requests.&lt;/p&gt;

&lt;p&gt;But typical action composition can be messy. Using action builders, we can simplify the process - and you may have already used them without realising it!&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ve probably seen code like this before, it&amp;rsquo;s pretty standard stuff:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Action { request =&amp;gt;
  Ok(views.html.index(&amp;quot;Your new application is ready.&amp;quot;))
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And if you&amp;rsquo;ve used Play Framework asynchronously, maybe something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Action.async { request =&amp;gt;
  doSomething map { result =&amp;gt;
    Ok(views.html.index(&amp;quot;Your new application is ready.&amp;quot;))
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also easily parse the request using a different content type (or &amp;ldquo;body parser&amp;rdquo;), for example using JSON:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Action.async(parse.json) { request =&amp;gt;
  doSomething map { result =&amp;gt;
    Ok(Json.obj(result -&amp;gt; &amp;quot;Your new application is ready.&amp;quot;))
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All of these use the Action action builder (that is, the Action object, which is an action builder).&lt;/p&gt;

&lt;p&gt;By creating a new action builder, we can create a drop-in replacement for the Action calls (both &lt;code&gt;Action&lt;/code&gt; and &lt;code&gt;Action.async&lt;/code&gt;), while still supporting the body parser parameter.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-new-action-builder:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Creating a new action builder&lt;/h2&gt;

&lt;p&gt;Since &lt;code&gt;Action&lt;/code&gt; is just an implementation of &lt;code&gt;ActionBuilder[Request]&lt;/code&gt;, we can extend &lt;code&gt;ActionBuilder&lt;/code&gt; to use in place of &lt;code&gt;Action&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;ActionBuilder requires that we implement &lt;code&gt;invokeBlock&lt;/code&gt;, and that&amp;rsquo;s where the magic happens. This is a bare minimum implementation, and its exactly what &lt;code&gt;Action&lt;/code&gt; does for us already.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;invokeBlock&lt;/code&gt; takes two parameters, the first is the incoming request, and the second is the function body, taking &lt;code&gt;Request[A]&lt;/code&gt; as a parameter and returning a &lt;code&gt;Future[SimpleResult]&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;object Interceptor extends ActionBuilder[Request] {
  def invokeBlock[A](request: Request[A], block: (Request[A]) =&amp;gt; Future[SimpleResult]) = block(request)
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It doesn&amp;rsquo;t do much (in fact, nothing different from &lt;code&gt;Action&lt;/code&gt;), but now we can use that in our controller instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Interceptor.async(parse.json) { request =&amp;gt;
  doSomething map { result =&amp;gt;
    Ok(Json.obj(result -&amp;gt; &amp;quot;Your new application is ready.&amp;quot;))
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And it works using the same syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Interceptor { request =&amp;gt; Ok }
def index = Interceptor.async { request =&amp;gt; future { Ok } }
def index = Interceptor(parse.json) { request =&amp;gt; Ok }
def index = Interceptor.async(parse.json) { request =&amp;gt; future { Ok } }
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;intercepting-requests:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Intercepting requests&lt;/h3&gt;

&lt;p&gt;There&amp;rsquo;s many reasons to intercept a request before it reaches your controller - authentication, authorisation, rate limiting or performance monitoring - for this example, we&amp;rsquo;ll use authentication.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s also many ways to authenticate a request - using headers, cookies, etc. - and while this is one way you certainly wouldn&amp;rsquo;t do it, it works for a demo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;object Authenticated extends ActionBuilder[Request] {
  def invokeBlock[A](request: Request[A], block: (Request[A]) =&amp;gt; Future[SimpleResult]) = {
    if(request.headers.get(&amp;quot;Authorization&amp;quot;).isDefined)
      block(request)
    else
      future { Results.Status(Status.UNAUTHORIZED) }
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This very simple example checks for an Authorization header.&lt;/p&gt;

&lt;p&gt;If it&amp;rsquo;s there, it calls &lt;code&gt;block(request)&lt;/code&gt; and request processing continues as expected (don&amp;rsquo;t confuse the word &amp;ldquo;block&amp;rdquo; to mean the request gets blocked, we&amp;rsquo;re actually executing the code block or function body we were passed earlier).&lt;/p&gt;

&lt;p&gt;If the Authorization header isn&amp;rsquo;t found, it returns an Unauthorized (401) response, using &lt;code&gt;Results.Status()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;At this point we could have returned any &lt;code&gt;Future[SimpleResult]&lt;/code&gt; we like. We could look up data in memcached, MongoDB or call a remote API using OAuth2 - and either let the request continue, or return an appropriate response instead.&lt;/p&gt;

&lt;p&gt;But this isn&amp;rsquo;t ideal - we&amp;rsquo;ve got our action builder sending a response to the client. We need to pass that responsibility back to the controller.&lt;/p&gt;

&lt;h3 id=&#34;passing-user-context:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Passing user context&lt;/h3&gt;

&lt;p&gt;So far, we&amp;rsquo;ve intercepted the request using action composition, but once we get to the controller code we don&amp;rsquo;t know who the user is, and no way to find out if we couldn&amp;rsquo;t establish the users identity.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s plenty of ways to fix this - &lt;a href=&#34;http://www.playframework.com/documentation/2.2.x/ScalaActionsComposition&#34;&gt;some of them documented in the Play Framework action composition documentation&lt;/a&gt; - but we&amp;rsquo;ll go with wrapping the request class.&lt;/p&gt;

&lt;p&gt;This has the advantage of keeping all existing code &amp;lsquo;compatible&amp;rsquo; - we can simply search and replace Action for Authenticated and every endpoint is protected.&lt;/p&gt;

&lt;p&gt;For a comparison, here&amp;rsquo;s what the controller would have looked like if we&amp;rsquo;d wrapped the action:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Authenticated { user =&amp;gt; 
  Action { request =&amp;gt;
    Ok(user.get)
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here&amp;rsquo;s what we&amp;rsquo;re going to create with our custom request class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Authenticated { request =&amp;gt;
  Ok(request.user.get)
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;wrapping-the-request-class:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Wrapping the request class&lt;/h4&gt;

&lt;p&gt;To wrap the request class, and be able to access the user object from our controllers without casting the request first, we need to create a new trait and a new object.&lt;/p&gt;

&lt;p&gt;The trait &lt;code&gt;AuthenticatedRequest&lt;/code&gt; simply extends &lt;code&gt;Request&lt;/code&gt; and adds a user value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;trait AuthenticatedRequest[+A] extends Request[A] {
  val user: Option[JsObject]
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The object &lt;code&gt;AuthenticatedRequest&lt;/code&gt; is similar to &lt;code&gt;play.api.mvc.Http.Request&lt;/code&gt; - except we copy the existing request, and add the user value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;object AuthenticatedRequest {
  def apply[A](u: Option[JsObject], r: Request[A]) = new AuthenticatedRequest[A] {
    def id = r.id
    def tags = r.tags
    def uri = r.uri
    def path = r.path
    def method = r.method
    def version = r.version
    def queryString = r.queryString
    def headers = r.headers
    lazy val remoteAddress = r.remoteAddress
    def username = None
    val body = r.body
    val user = u
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we need to change our call to &lt;code&gt;block(request)&lt;/code&gt; to pass through our new &lt;code&gt;AuthenticatedRequest&lt;/code&gt; object.&lt;/p&gt;

&lt;p&gt;To make this work, we also need to change &lt;em&gt;some&lt;/em&gt; of the &lt;code&gt;Request&lt;/code&gt; types to &lt;code&gt;AuthenticatedRequest&lt;/code&gt; in our &lt;code&gt;Authenticated&lt;/code&gt; object. We&amp;rsquo;ve also let the request continue even without a valid user - we can use this from a controller to know the users identity couldn&amp;rsquo;t be established.&lt;/p&gt;

&lt;p&gt;Here it is in full:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;object Authenticated extends ActionBuilder[AuthenticatedRequest] {
  def invokeBlock[A](request: Request[A], block: (AuthenticatedRequest[A]) =&amp;gt; Future[SimpleResult]) = {
    if(request.headers.get(&amp;quot;Authorization&amp;quot;).isDefined)
      block(AuthenticatedRequest[A](Some(Json.obj()), request))
    else
      block(AuthenticatedRequest[A](None, request))
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that invokeBlock still expects a &lt;code&gt;Request[A]&lt;/code&gt; as its request parameter, but now the block parameter defines a function with a &lt;code&gt;AuthenticatedRequest[A]&lt;/code&gt; parameter instead.&lt;/p&gt;

&lt;p&gt;For now, our user is nothing more than an empty JsObject. In a real application, it could be any type (not just JsObject), and the value for user could come from anywhere (e.g. a database, session, OAuth2, etc).&lt;/p&gt;

&lt;p&gt;When authentication fails, we pass through &lt;code&gt;None&lt;/code&gt;, letting the controller know that no user could be found.&lt;/p&gt;

&lt;p&gt;From our controller, we can now access the user object with &lt;code&gt;request.user&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Authenticated.async { request =&amp;gt;
  future { Ok(request.user.get) }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;authorisation:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Authorisation&lt;/h3&gt;

&lt;p&gt;So far we&amp;rsquo;ve seen how to require authentication using an action builder. While this is useful if your app uses an &amp;lsquo;all or nothing&amp;rsquo; security model, this isn&amp;rsquo;t particularly useful for authorisation, for example in role based security.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s two easy ways to solve this problem:&lt;/p&gt;

&lt;h4 id=&#34;create-another-action-builder-to-wrap-our-authenticated-builder:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Create another action builder to wrap our Authenticated builder&lt;/h4&gt;

&lt;p&gt;We can wrap our Authenticated action builder with another builder, giving us controller code that might look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Authorised(roles = List(&amp;quot;blog.post&amp;quot;)) { request =&amp;gt;
  Ok(request.user.get)
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is very straightforward, but creates an unnecessary dependency between your authorisation and authentication code.&lt;/p&gt;

&lt;h4 id=&#34;use-normal-action-composition-to-require-authorisation:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Use normal action composition to require authorisation&lt;/h4&gt;

&lt;p&gt;Using action composition, we might end up with code that looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Authenticated { request =&amp;gt;
  Authorised(roles = List(&amp;quot;blog.post&amp;quot;)) {
    Ok(request.user.get)
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we can also do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Authorised(roles = List(&amp;quot;blog.post&amp;quot;)) { request =&amp;gt;
  Ok(request.user.get)
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The downside to normal action composition is obvious once you start using different body parsers or asynchronous operations:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Authenticated(parse.json).async { request =&amp;gt;
  Authorised(parse.json).async(roles = List(&amp;quot;blog.post&amp;quot;)) {
    future { Ok(request.user.get) }
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On every nested action we are required to redeclare the body parser and call async.&lt;/p&gt;

&lt;h4 id=&#34;but-this-is-scala-there-s-a-nicer-way:8a4e04e27a605e28f409c700d00877c8&#34;&gt;But this is Scala - there&amp;rsquo;s a nicer way!&lt;/h4&gt;

&lt;p&gt;Neither of those examples are particularly suitable. Neither will cleanly handle a negative outcome (either needing some messy code or hiding the unauthorised response away in a helper class), and neither of them nest well.&lt;/p&gt;

&lt;p&gt;Whenever you need to check authorisation, the outcome is normally one of two things - in the case of a web application, its likely that both of them will end in returning some content to the user.&lt;/p&gt;

&lt;p&gt;In true MVC style, this shouldn&amp;rsquo;t be the responsibility of the authorisation code. It should be in the controller.&lt;/p&gt;

&lt;p&gt;We could just use an if/then/else statement, but I like something a bit cleaner:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Authenticated { request =&amp;gt;
  Authorised(request, request.user) {
    Ok(request.user.get)
  } otherwise {
    Unauthorized
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And our &lt;code&gt;Authorised&lt;/code&gt; implementation is simple. We provide &lt;code&gt;Authorised&lt;/code&gt; and &lt;code&gt;Authorised.async&lt;/code&gt; functions, and return an instance of our &lt;code&gt;Authorised&lt;/code&gt; class providing an &lt;code&gt;otherwise&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;object Authorised {
  def async[T](request: Request[T], user: Option[JsObject]) = {
    (block: Future[SimpleResult]) =&amp;gt; new Authorised[T](request, user, block)
  }
  def apply[T](request: Request[T], user: Option[JsObject]) = {
    (block: SimpleResult) =&amp;gt; new Authorised[T](request, user, future { block })
  }
}

class Authorised[T](request: Request[T], user: Option[JsObject], success: Future[SimpleResult]) {
  def authorised = {
    if(user.isDefined) true else false
  }
  def otherwise(block: Future[SimpleResult]) : Future[SimpleResult] = authorised.flatMap { valid =&amp;gt; if (valid) success else block }
  def otherwise(block: SimpleResult) : SimpleResult = if(authorised.value.get.get) success.value.get.get else block
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As with the Authentication action builder, this implementation isn&amp;rsquo;t particularly secure. As long as the user is defined (which it will be if the Authorization header is set), then authorisation is successful.&lt;/p&gt;

&lt;p&gt;In this example we&amp;rsquo;ve also passed the request object to the authorisation layer. It would be cleaner to abstract the request from our authorisation code using named roles or permissions.&lt;/p&gt;

&lt;h3 id=&#34;action-builder-vs-helper-object:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Action builder vs helper object&lt;/h3&gt;

&lt;p&gt;There&amp;rsquo;s a reason we&amp;rsquo;ve created authentication as an action builder but kept authorisation as a helper object.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Authentication&lt;/em&gt; is a one-time process (for each request) - it rarely needs to be done multiple times, and it rarely changes once the request has been received. Even if we can&amp;rsquo;t establish the identity of the user, that doesn&amp;rsquo;t necessarily mean authentication has failed or that the user has no permissions.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Authorisation&lt;/em&gt; can happen multiple times within one request, in one controller, and with distinct outcomes - for example, rendering a dashboard might perform multiple unique authorisation checks to determine appropriate components for a single page.&lt;/p&gt;

&lt;p&gt;By keeping the authorisation check as a helper object, we can use it mutliple times within a controller action, passing different parameters each time, and with the flexibility to control the outcome of each check.&lt;/p&gt;

&lt;p&gt;For example, we could return &lt;code&gt;NotFound&lt;/code&gt; for one level of authorisation failure, but &lt;code&gt;Unauthorized&lt;/code&gt; for another:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def index = Authenticated(parse.json) { request =&amp;gt;
  Authorised(request, request.user) {
    Authorised(request, Some(Json.obj())) {
      Ok(request.user.get)
    } otherwise {
      Unauthorized
    }
  } otherwise {
    NotFound
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;summary:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ve now created an authentication and authorisation layer for our web application, which supports the same syntax as the built in Play objects. For a simple application, that&amp;rsquo;s all you need - just wire in MongoDB or OAuth2!&lt;/p&gt;

&lt;p&gt;The same idea can be applied to any other type of wrapper. You can even create action builders and helper objects which combine other wrappers, for example automatically applying authentication, authorisation and rate limiting through a single builder.&lt;/p&gt;

&lt;h2 id=&#34;going-a-bit-further-with-akka:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Going a bit further with Akka&lt;/h2&gt;

&lt;p&gt;While it would be easy to extend that example to lookup users, roles and permissions in MongoDB, or restrict actions based on IP address, in Scala (and Play Framework) we can do things a little differently.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s no reason for authentication or authorisation to be tied to your application - they aren&amp;rsquo;t really a direct responsibility of your web application anyway, but they&amp;rsquo;re often left there for convenience.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://akka.io&#34;&gt;Akka&lt;/a&gt; provides us with a framework to build distributed and concurrent applications - and we can keep our application concurrent and distributed right through to the authentication and authorisation layers. And better yet, it&amp;rsquo;s already used internally by Play Framework.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll extend this example to use an actor for authentication and authorisation, giving us the flexibility to move our authentication code anywhere - even to a remote service with Akka remoting.&lt;/p&gt;

&lt;h3 id=&#34;creating-an-actor:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Creating an actor&lt;/h3&gt;

&lt;p&gt;For now, we&amp;rsquo;ll just keep our actor next to our action builder. Moving it around later is easy.&lt;/p&gt;

&lt;p&gt;First we&amp;rsquo;ll create some basic case classes to communicate using Akka:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;case class Authenticate[A](request: Request[A])
case class AuthenticationResult(valid: Boolean, user: Option[JsObject] = None)
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can extend these classes if we want to provide additional context or return additional information.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s our basic actor - it implements a receive function to handle incoming messages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;class Authenticator extends Actor {
  def receive = {
    case Authenticate(request) =&amp;gt; 
      if(request.headers.get(&amp;quot;Authorization&amp;quot;).isDefined)
        sender ! AuthenticationResult(valid = true, user = Json.obj())
      else 
        sender ! AuthenticationResult(valid = false)
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s only job is to return an AuthenticationResult depending on the request. It provides the same super strength foolproof security we had with our earlier example.&lt;/p&gt;

&lt;h3 id=&#34;using-the-actor-for-authentication:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Using the actor for authentication&lt;/h3&gt;

&lt;p&gt;We need to get an instance of our actor for our &lt;code&gt;Authenticated&lt;/code&gt; object. We&amp;rsquo;ll send &lt;code&gt;Authenticate&lt;/code&gt; requests to the actor, and get an &lt;code&gt;AuthenticationResult&lt;/code&gt; back:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;val authenticationActor = Akka.system.actorOf(Props[Authenticator], name = &amp;quot;authentication&amp;quot;)
implicit val timeout = Timeout(1 second)
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now update our &lt;code&gt;invokeBlock&lt;/code&gt; function to use the actor instead of including its own authentication logic. If authentication was successful, the actor returns the &lt;code&gt;JsObject&lt;/code&gt; representing the user.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;def invokeBlock[A](request: Request[A], block: (AuthenticatedRequest[A]) =&amp;gt; Future[SimpleResult]) = {
  (authenticationActor ask Authenticate(request)).mapTo[AuthenticationResult] flatMap { result =&amp;gt;
    if(result.valid)
      block(AuthenticatedRequest[A](Some(result.user.get), request))
    else
      block(AuthenticatedRequest[A](None, request))
  } recover {
    case e =&amp;gt; Results.Status(Status.INTERNAL_SERVER_ERROR)
  }
}
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can extend our authorisation class in exactly the same way, again sending the authorisation request to an actor. I&amp;rsquo;ll skip it here since the code is so similar to the authentication actor, but you can find it in the full source code on &lt;a href=&#34;https://gist.github.com/ian-kent/8941847&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;summary-1:8a4e04e27a605e28f409c700d00877c8&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Action composition in Play Framework is surprisingly easy, and very powerful.&lt;/p&gt;

&lt;p&gt;Using action builders combined with Scala&amp;rsquo;s concurrency and Akka&amp;rsquo;s distributed framework, it&amp;rsquo;s simple to keep your controller code clean without sacrificing security or scalability across your application.&lt;/p&gt;

&lt;p&gt;Full source code for the Akka example can be &lt;a href=&#34;https://gist.github.com/ian-kent/8941847&#34;&gt;found on GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>